<style>
  pre {
    background-color: rgba(255, 255, 255, 0.7);
    padding: 2px 4px;
    border-radius: 4px;
    font-size: 1.2em;
  }
</style>

<h2>Hvorfor snakke om Elm i 2025?</h2>

<p>
  I en verden dominert av React, Vue og Svelte kan det virke merkelig å løfte
  frem Elm – et nisje-språk som har eksistert siden 2012, men som nesten har
  færre releases siden da enn React har på et år. Men nettopp nå, når
  frontend-utviklingen blir stadig mer kompleks, og hvor klientene gjør tunge
  løft som før hørte hjemme på andre siden av et API-kall, er det verdt å se
  nærmere på hva Elm gjør riktig.
</p>

<h2>Hva er Elm?</h2>

<p>
  Elm er et funksjonelt programmeringsspråk spesielt designet for
  webapplikasjoner. Her er nøkkelforskjellene fra moderne JavaScript-rammeverk:
</p>

<p>
  - <strong>Ingen runtime-feil</strong> – Når koden kompilerer, kan den kjøre
  uten uventede krasj<br />
  - <strong>Fullstendig håndtering av all mulig state</strong> – Kompilatoren
  hjelper deg med alle grensetilfeller<br />
  - <strong>Forutsigbar arkitektur</strong> –
  <a href="https://guide.elm-lang.org/architecture/">The Elm Architecture</a>
  (TEA) gir en klar struktur som skalerer godt<br />
  - <strong>Automatisk versjonshåndtering</strong> – Kompilatoren oppdager
  breaking changes
</p>

<h3>React vs. Elm: Samme retning, ulik tilnærming</h3>

<p>Det er fascinerende å se hvordan React har utviklet seg de siste årene:</p>

<p>
  - React introduserte hooks for å håndtere state mer funksjonelt<br />
  - Redux (inspirert av Elm) ble standard for kompleks håndtering av state<br />
  - TypeScript (sterk typing) ble nesten obligatorisk for seriøse prosjekter<br />
  - React Server Components isolerer sideeffekter på serversiden
</p>

<p>
  <strong>Men det er en viktig forskjell:</strong> React
  <em>anbefaler</em> funksjonell programmering og immutabilitet, mens Elm
  <em>krever</em> det. I React kan du fortsatt mutere variabler og state, blande
  paradigmer, og skape runtime-feil. I Elm er det rett og slett umulig. For ikke
  å snakke om hvor historieløs og uansvarlig tilnærming til arkitektur man
  finner i både store og små React-prosjekter.
</p>

<p>
  Som en senior React-utvikler sa til meg nylig: "God React-kode i 2025 ligner
  mistenkelig på Elm-kode fra 2015."
</p>

<h3>En kjapp historietime før vi går videre</h3>

<p>
  For å forstå hvorfor Elm er bygget som det er, og hvorfor det fortsatt er
  relevant, må vi ta et skritt tilbake og se på den større historien om
  programmeringsparadigmer. Denne utviklingen handler om noe fundamentalt:
  <strong
    >Hvordan vi gradvis har fjernet farlige friheter for å skape mer pålitelig
    kode.</strong
  >
</p>

<p>
  <strong>Merk</strong>: Nå skal det sies at funksjonell programmering strengt
  tatt er eldre enn de andre paradigmene. Men jeg velger likevel å plassere det
  på slutten av en rekke iterasjoner som utvikler seg fra kaos til kontroll.
</p>

<h3>Paradigmeutvikling: Å ta vekk muligheter for å få mer kontroll</h3>

<h2>🏗 Før strukturert programmering – <em>"Full frihet, full kaos"</em></h2>

<p>
  Før 1960-tallet skrev utviklere ofte kode i en
  <strong>rent imperativ stil</strong>, hvor programmer besto av sekvenser av
  kommandoer med <strong>GOTO-setninger</strong> for å hoppe mellom ulike deler
  av programmet.
</p>

<p>
  🔴 <strong>Problem:</strong> Koden ble vanskelig å forstå og vedlikeholde
  («spaghetti-kode»). Ingen garantier for at en sekvens av operasjoner var
  fornuftig, og feil ble uforutsigbare. "Undefined behaviour" ble en slags
  obligatorisk blindpassasjer.
</p>

<hr />

<h2>📏 Strukturert programmering – <em>"Ingen flere vilkårlige hopp!"</em></h2>

<p>
  <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra"
    >Edsger W. Dijkstra</a
  >
  og andre datavitere på 1960-70-tallet argumenterte for at all programlogikk
  burde kunne uttrykkes gjennom
  <strong>sekvenser, valg (if/while/switch) og løkker</strong>. Dette gjorde
  programmer mer forutsigbare. Dijkstras berømte artikkel
  <a href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf"
    >"Go To Statement Considered Harmful"</a
  >
  (1968) var et vendepunkt.
</p>

<p>
  ✂ <strong>Fjernet:</strong> GOTO<br />
  ✅ <strong>Resultat:</strong> Klarere kontrollflyt, lettere å debugge
</p>

<hr />

<h2>🏛 Objektorientert programmering (OOP) – <em>"Trygg polymorfisme!"</em></h2>

<p>
  OOP oppsto på 1980-90-tallet som en respons på behovet for mer fleksible og
  utvidbare systemer. Den største innovasjonen var – etter min mening – kanskje
  ikke innkapsling av tilstand, men <strong>trygg polymorfisme</strong> gjennom
  grensesnitt og arv.
</p>

<p>
  ✂ <strong>Fjernet:</strong> Utrygge "pointers to functions" og hardkodede
  avhengigheter<br />
  ✅ <strong>Resultat:</strong>
</p>

<p>
  -
  <strong
    ><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle"
      >Dependency Inversion</a
    ></strong
  >
  – Høynivåmoduler kan nå avhenge av abstraksjoner, ikke konkrete
  implementasjoner<br />
  - <strong>Plugin-arkitektur</strong> – Systemer kan utvides uten å endre
  eksisterende kode<br />
  - <strong>Testbarhet</strong> – Avhengigheter kan enkelt byttes ut med
  mock-objekter
</p>

<p>
  Før OOP måtte utviklere bruke farlige "pointers to functions" for å oppnå
  polymorfisme. OOP gjorde dette trygt og forutsigbart gjennom virtuelle
  funksjoner og grensesnitt. Som
  <a
    href="https://blog.cleancoder.com/uncle-bob/2016/01/04/ALittleArchitecture.html"
    >Robert C. Martin ("Uncle Bob")</a
  >
  påpeker, var dette et stort fremskritt for arkitektonisk fleksibilitet.
</p>

<hr />

<h2>
  🧩 Funksjonell programmering (FP) –
  <em>"Fjern mutabilitet og bivirkninger!"</em>
</h2>

<p>
  FP har riktignok røtter tilbake til 1950-tallet (<a
    href="https://en.wikipedia.org/wiki/Lisp_(programming_language)"
    >Lisp</a
  >), men fikk økt popularitet med språk som
  <a href="https://www.haskell.org/">Haskell</a>, Elm og moderne bruk i
  TypeScript og React. Målet er å eliminere
  <strong>uventede bivirkninger</strong>, sikre at funksjoner alltid gir samme
  output for samme input, og unngå delt state. Jeg har valgt å se på det som
  neste (og siste) iterasjon på stigen mot å fjerne kaos.
</p>

<p>✂ <strong>Fjernet:</strong></p>

<p>
  - Mutabel state<br />
  - Skjulte side effects<br />
  - Objektorientert kompleksitet
</p>

<p>
  ✅ <strong>Resultat:</strong> Mer forutsigbar og testbar kode, men ofte
  brattere læringskurve.
</p>

<hr />

<h2>
  🔄 Fellesnevner: Hver epoke har handlet om å fjerne feilbarlige friheter (ikke
  legge til nye fancy features)
</h2>

<p>
  1. <strong>Strukturert programmering:</strong> Fjernet vilkårlige hopp
  (GOTO)<br />
  2. <strong>OOP:</strong> Fjernet ukontrollert deling av state<br />
  3. <strong>FP:</strong> Fjernet mutabilitet og skjulte side effects
</p>

<p>
  Målet har alltid vært det samme: <strong>Mindre kaos, mer kontroll</strong>.
  🔥
</p>

<p>
  Dette er selvsagt en forenklet fremstilling av programmeringshistorien, men
  essensen er klar:
  <strong
    >God kode handler ikke om maksimal frihet, men om velvalgte
    begrensninger.</strong
  >
  De beste verktøyene hjelper oss å unngå feil, ikke bare å rette dem.
</p>

<h3>Elm: Radikalt funksjonelt</h3>

<p>
  Elm tar dette siste skrittet radikalt ved å gjøre immutabilitet obligatorisk:
</p>

<pre><code>-- Eksempel på Elm som forbyr mutasjon
update : Model -> Model
update model =
    { model | count = model.count + 1 }  -- Returnerer NY modell, mutasjon er umulig

-- Kompilatoren vil stoppe deg hvis du prøver:
-- model.count = 5  ← Kompileringsfeil!
</code></pre>

<p>
  Dette minner om
  <a
    href="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/SimpleMadeEasy.md"
    >Rich Hickeys</a
  >
  påstand om enkelthet gjennom begrensninger i hans berømte foredrag
  <a href="https://www.youtube.com/watch?v=SxdOUGdseq4">"Simple Made Easy"</a>,
  og <a href="http://worrydream.com/">Bret Victors</a> observasjon fra
  <a href="https://www.youtube.com/watch?v=PUv66718DII"
    >"Inventing on Principle"</a
  >: "The most important property of a program is whether it is correct. The
  second most important is whether it can be changed without breaking its
  correctness."
</p>

<h3>Når begrensninger gir frihet</h3>

<p>Ironisk nok gir Elms strenge begrensninger oss flere fordeler:</p>

<p>
  - <strong>Enklere feilsøking</strong>: Når data aldri endres, slipper du å
  lure på "hvem eller hva endret denne verdien?"
</p>

<pre><code>// I JavaScript kan dette skje:
let user = { name: "Ada" };
someFunction(user); // user kan bli endret her
console.log(user.name); // Hva er navnet nå? Umulig å vite uten å lese someFunction

// Du kan også re-assigne `let`
user = "user is now a string, not an object!";
console.log(user.name); // Nå er user.name `undefined`
</code></pre>

<p>
  I Elm er dette umulig - du får compile-time error hvis du prøver å mutere:
</p>

<pre><code>-- I Elm:
user = { name = "Ada" }

-- Dette kompilerer ikke:
user.name = "Grace"  -- FEIL: Elm har ikke variabel-mutasjon.

-- Dette kompilerer heller ikke:
user = { name = "Grace" }  -- FEIL: Elm kan ikke re-assigne variabler

-- Riktig måte i Elm:
updatedUser = { user | name = "Grace" }  -- Lager en ny kopi med endret navn

-- Eller i en funksjon med let-in:
updateName name user =
    let
        updatedUser = { user | name = name }
    in
    updatedUser
</code></pre>

<p>
  - <strong>Forutsigbar kode</strong>: Rene funksjoner + uforanderlige data =
  samme input gir alltid samme output<br />
  - <strong>Tryggere refaktorering</strong>: Kompilatoren finner alle steder som
  må oppdateres<br />
  - <strong>Mindre mental belastning</strong>: Du trenger ikke holde hele
  tilstandshistorikken i hodet
</p>

<pre><code>view : Model -> Html Msg  -- Kun gjeldende state er relevant
</code></pre>

<p>
  Mye av dette ligner unektelig på hvordan React kan se ut i beste fall. Men Elm
  tvinger deg inn i "beste fall"!
</p>

<h3>Moderne fordeler i praksis</h3>

<p>I 2025 gir Elm flere konkrete fordeler for moderne webapplikasjoner:</p>

<p>
  1. <strong>Null runtime exceptions</strong> – Når koden kompilerer, krasjer
  den ikke:
</p>

<pre><code>-- Dette kompilerer ikke:
text 5  -- Type error: Expected String, got Int

-- Dette kompilerer:
text (String.fromInt 5)  -- Trygt og forutsigbart
</code></pre>

<p>
  2. <strong>Automatisk refaktorering</strong> – Kompilatoren finner alle steder
  som må endres:
</p>

<pre><code>-- Endre en datamodell:
type alias User = { name : String }
↓
type alias User = { name : String, email : String }

-- Kompilatoren markerer alle funksjoner som må oppdateres
</code></pre>

<p>
  3. <strong>Garantert håndtering av alle tilstander</strong> – Ingen "undefined
  is not a function":
</p>

<pre><code>-- Må håndtere både Just og Nothing:
case maybeUser of
    Just user ->
        viewUser user

    Nothing ->
        text "Ingen bruker funnet"
</code></pre>

<p>
  4. <strong>Optimalisert rendering</strong> – Virtual DOM med automatisk
  diffing:
</p>

<pre><code>-- Elm oppdaterer bare DOM-elementer som faktisk endres
view : Model -> Html Msg
view model =
    div []
        [ header [] [ text model.title ]
        , content [] [ text model.content ]
        ]
</code></pre>

<p>5. <strong>Forutsigbar state management</strong> – Én kilde til sannhet:</p>

<pre><code>-- All state er samlet i én modell
type alias Model =
    { users : List User
    , currentPage : Page
    , isLoading : Bool
    }
</code></pre>

<h2>SOLID by default</h2>

<p>
  Elm-arkitekturen (The Elm Architecture, eller bare TEA) er en enkel, men
  kraftfull modell for å bygge webapplikasjoner. Den består av tre hoveddeler:
</p>

<p>
  1. <strong>Model</strong> - Applikasjonens tilstand<br />
  2. <strong>Update</strong> - Hvordan tilstanden endres som respons til
  hendelser<br />
  3. <strong>View</strong> - Hvordan tilstanden vises i brukergrensesnittet
</p>

<img
  src="https://guide.elm-lang.org/architecture/buttons.svg"
  alt="The Elm Architecture Diagram"
/>
<em
  >Bildekilde:
  <a href="https://guide.elm-lang.org/architecture/">Elm Guide</a></em
>

<h3>Hvordan det fungerer</h3>

<p>
  1. <strong>Brukerinteraksjon</strong> trigger en
  <code>Msg</code> (melding)<br />
  2. <code>Update</code>-funksjonen tar imot meldingen og returnerer en ny
  <code>Model</code><br />
  3. Den nye <code>Model</code>-en sendes til <code>View</code>-funksjonen<br />
  4. <code>View</code>-funksjonen genererer ny HTML som vises til brukeren
</p>

<p>
  Dette mønsteret tvinger frem
  <a href="https://en.wikipedia.org/wiki/SOLID">SOLID-prinsippene</a> – enten du
  vil eller ikke:
</p>

<p>
  1.
  <strong
    ><a href="https://en.wikipedia.org/wiki/Single-responsibility_principle"
      >Single Responsibility</a
    ></strong
  >
  – Elm tvinger deg til å separere View, Update og Model. Hver funksjon har én
  jobb, og én "reason to change", og kompilatoren klager hvis du prøver å blande
  ansvarsområder.<br />
  2.
  <strong
    ><a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle"
      >Open/Closed</a
    ></strong
  >
  – Ny funksjonalitet legges til ved å utvide Msg-typen med nye varianter, ikke
  ved å modifisere eksisterende kode. Elm-arkitekturen er designet for
  utvidelse!<br />
  3.
  <strong
    ><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle"
      >Liskov Substitution</a
    ></strong
  >
  – Automatisk oppfylt gjennom Elms typesystem og union types:
</p>

<pre><code>-- I Elm er LSP umulig å bryte - kompilatoren tillater det ikke
type Shape
    = Circle Float
    | Rectangle Float Float

area : Shape -> Float
area shape =
    case shape of
        Circle radius ->
            pi * radius * radius

        Rectangle width height ->
            width * height

-- Prøv å legge til Triangle uten å oppdatere area-funksjonen
-- Kompilatoren: "Godt forsøk, prøv igjen."
</code></pre>

<p>
  4.
  <strong
    ><a href="https://en.wikipedia.org/wiki/Interface_segregation_principle"
      >Interface Segregation</a
    ></strong
  >
  – Elm oppmuntrer til små, fokuserte moduler og typer. Ingen "mega-interfaces"
  som tvinger implementasjoner til å støtte unødvendige metoder.<br />
  5.
  <strong
    ><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle"
      >Dependency Inversion</a
    ></strong
  >
  – All kommunikasjon går gjennom meldinger (Msg) og abstraksjoner.
  Høynivåmoduler avhenger aldri av lavnivådetaljer.
</p>

<p>
  Der andre språk tilbyr SOLID som "best practices" du kan følge hvis du er
  disiplinert, er de en obligatorisk del av Elms DNA. Kompilatoren er din
  ubarmhjertige arkitektur-mentor.
</p>

<p>(Og så har du C#, som selv bryter LSP i innebygde typer:</p>

<pre><code>ArrayList list = new List&lt;int&gt;(); // Skal fungere i teorien, men gjør ikke det
list.Add("Hello"); // Dette er lov i ArrayList, men ikke i List&lt;int&gt;
int num = (int)list[0]; // Kaster runtime-feil hvis string er lagt til
</code></pre>

<p>, men det er en annen artikkel.)</p>

<h2>The Elm Architecture vs. Clean Architecture</h2>

<p>
  Clean Architecture (CA) handler om å organisere kode slik at
  forretningslogikken er uavhengig av rammeverk og UI. Hvordan passer TEA inn
  her?
</p>

<h3>1. Separerer UI fra logikk</h3>

<p>
  - Akkurat som CA, har TEA en klar separasjon mellom presentasjonslaget
  (<strong>View</strong>) og domenelogikken (<strong>Model + Update</strong
  >).<br />
  - Dette betyr at man kan endre UI uten å endre domenelogikken.
</p>

<h3>2. Strukturering av forretningslogikk</h3>

<p>
  - TEA har ikke et eksplisitt "use case-lag" slik CA anbefaler.<br />
  - Men <strong>Update-funksjonen</strong> kan sees på som en
  <em>interactor</em> i CA, hvor den tar inn en hendelse og bestemmer en
  tilstandsendring.
</p>

<h3>3. Uavhengighet fra eksterne systemer</h3>

<p>
  - I Clean Architecture skal forretningslogikken være
  <strong>uavhengig</strong> av databaser, UI eller tredjeparts API-er.<br />
  - TEA sikrer dette ved å bruke <strong>Cmd</strong> for sideeffekter, slik at
  API-kall og lignende ligger utenfor kjernearkitekturen.
</p>

<h3>4. Enkel testing</h3>

<p>
  - Begge arkitekturer fremmer <strong>testbar kode</strong>.<br />
  - TEA sin rene funksjonelle tilnærming gjør det lett å enhetsteste
  <strong>Update-funksjonen</strong> uten å tenke på eksterne avhengigheter.
</p>

<hr />

<h3>Oppsummering</h3>

<table>
  <thead>
    <tr>
      <th><strong>Kriterium</strong></th>
      <th><strong>The Elm Architecture</strong></th>
      <th><strong>Clean Architecture</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Separasjonsprinsipp</strong></td>
      <td>God separasjon av UI, logikk og tilstand</td>
      <td>Fremmer separasjon av lag</td>
    </tr>
    <tr>
      <td><strong>Utvidbarhet</strong></td>
      <td>Enkel å utvide med nye meldinger, men Update kan bli stor</td>
      <td>Fremmer fleksibilitet</td>
    </tr>
    <tr>
      <td><strong>Testbarhet</strong></td>
      <td>Lett å teste pga. rene funksjoner</td>
      <td>Fremmer testbarhet</td>
    </tr>
    <tr>
      <td><strong>Uavhengighet av UI</strong></td>
      <td>Ja, via Model og Update</td>
      <td>Hovedmål i Clean Architecture</td>
    </tr>
    <tr>
      <td><strong>Sideeffekter</strong></td>
      <td>Håndteres via "Cmd"</td>
      <td>Anbefaler isolasjon av sideeffekter</td>
    </tr>
  </tbody>
</table>

<hr />

<p>
  TEA samsvarer overraskende godt også med Clean Architecture, selv om det er
  tilpasset en funksjonell kontekst. Spesielt
  <strong>separasjon av UI og logikk</strong>, testbarhet og håndtering av
  sideeffekter er sterke sider ved TEA. Hvis man vil bruke TEA i større
  systemer, kan det være nyttig å strukturere
  <strong>Update-funksjonen</strong> mer modulært, slik at den ikke blir en
  <em>God-funksjon</em>.
</p>

<h2>Moderne frontend-utvikling trenger dette</h2>

<p>
  I 2025 ser vi et paradoks: Verktøyene blir enklere, men applikasjonene blir
  mer komplekse. Elm adresserer dette gjennom:
</p>

<p>
  1. <strong>Typesikkerhet uten konfigurasjon</strong> – Ingen kompliserte
  TypeScript-oppsett<br />
  2. <strong>Trygg refaktorering</strong> – Kompilatoren finner alle steder som
  må endres<br />
  3. <strong>Isolerte sideeffekter</strong> – Gjør testing og feilsøking
  enklere<br />
  4. <strong>Felles arkitekturmønster</strong> – Reduserer diskusjoner om
  kodestruktur
</p>

<h2>Når bør du vurdere Elm?</h2>

<p>Elm passer spesielt godt når:</p>

<p>
  1. Du bygger en kompleks frontend-applikasjon<br />
  2. Robusthet og vedlikeholdbarhet er kritisk<br />
  3. Du har mulighet til å trene opp teamet<br />
  4. Du starter et nytt prosjekt fra bunnen
</p>

<h2>Utfordringene</h2>

<p>La oss være ærlige om utfordringene også:</p>

<p>
  - Bratt læringskurve for utviklere vant til imperativ programmering<br />
  - Mindre økosystem enn React/Vue<br />
  - Færre utviklere tilgjengelig<br />
  - Kan være vanskelig å "selge inn" til beslutningstakere
</p>

<h2>Konklusjon</h2>

<p>
  Elms relevans i 2025 ligger ikke i markedsandeler, men som arkitektonisk
  kompass. Mange av dens prinsipper finner vi igjen i:
</p>

<p>
  -
  <a
    href="https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components"
    >React Server Components</a
  >' isolering av effekter<br />
  - TypeScripts stadig strengere type-system<br />
  - Veksten av compile-time-verktøy som <a href="https://trpc.io/">tRPC</a> og
  <a href="https://zod.dev/">Zod</a>
</p>

<p>
  Igjen: det diverse "best-practices" oppfordrer den drevne utvikler til å legge
  vinn på, er en obligatorisk del av Elm. Visst kan (og bør!) du skrive
  funksjonell React med god arkitektur, sterke typer og isolerte side effects;
  med Elm får du rett og slett ikke lov til noe annet.
</p>

<h2>Ressurser for å komme i gang</h2>

<p>
  - <a href="https://guide.elm-lang.org/">Elm Guide</a> – Den offisielle
  guiden<br />
  - <a href="https://amzn.to/41z14kq">Elm in Action</a> – En utmerket bok for å
  lære hvordan Elm fungerer i større applikasjoner<br />
  - <a href="https://elm-lang.org/community">Elm Community</a> – Et uvanlig
  hjelpsomt og åpent community, inkludert Slack, Discourse osv<br />
  - <a href="https://www.elm-spa.dev/">elm-spa</a> – For å bygge Single Page
  Applications<br />
  - (Evt. mitt
  <a href="https://github.com/cekrem/create-elm-live-app"
    >hjemmesnekrede opplegg</a
  >
  fra gamledager, som gjør mye av det samme)<br />
  - <a href="https://elm.land/">Elm Land</a> – Nytt meta-rammeverk (2024)
</p>
