<!doctype html><html lang=en><head><title>A Use Case for Port Boundaries in Frontend Development ¬∑ cekrem.github.io</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Christian Ekrem"><meta name=description content="Learn how Elm's architectural discipline‚Äîand a few ideas from Clean Architecture‚Äîcan reshape how we think about frontend boundaries."><meta name=keywords content="developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cekrem.github.io/images/featured-with-margins.png"><meta name=twitter:title content="A Use Case for  Port Boundaries in Frontend Development"><meta name=twitter:description content="Learn how Elm's architectural discipline‚Äîand a few ideas from Clean Architecture‚Äîcan reshape how we think about frontend boundaries."><meta property="og:url" content="https://cekrem.github.io/posts/a-case-for-port-boundaries-in-frontend/"><meta property="og:site_name" content="cekrem.github.io"><meta property="og:title" content="A Use Case for  Port Boundaries in Frontend Development"><meta property="og:description" content="Learn how Elm's architectural discipline‚Äîand a few ideas from Clean Architecture‚Äîcan reshape how we think about frontend boundaries."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-19T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-19T00:00:00+00:00"><meta property="article:tag" content="Clean Architecture"><meta property="article:tag" content="Architecture"><meta property="article:tag" content="Elm"><meta property="article:tag" content="React"><meta property="article:tag" content="Frontend"><meta property="article:tag" content="Software Design"><meta property="og:image" content="https://cekrem.github.io/images/featured-with-margins.png"><link rel=canonical href=https://cekrem.github.io/posts/a-case-for-port-boundaries-in-frontend/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.d316f9beae37e349fb95fa7d4944e65ddb5a30bd371cafecb0ad79496568e957.css integrity="sha256-0xb5vq4340n7lfp9SUTmXdtaML03HK/ssK15SWVo6Vc=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-light"><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://cekrem.github.io/>cekrem.github.io
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/hire/>Hire me?</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/books-i-think-software-engineers-should-read>Recommended Books</a></li><li class=navigation-item><a class=navigation-link href=https://creators.spotify.com/pod/show/disippel>Podcast (üá≥üá¥)</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://cekrem.github.io/posts/a-case-for-port-boundaries-in-frontend/>A Use Case for Port Boundaries in Frontend Development</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-05-19T00:00:00Z>May 19, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
5-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/clean-architecture/>Clean Architecture</a>
</span><span class=separator>‚Ä¢</span>
<span class=tag><a href=/tags/architecture/>Architecture</a>
</span><span class=separator>‚Ä¢</span>
<span class=tag><a href=/tags/elm/>Elm</a>
</span><span class=separator>‚Ä¢</span>
<span class=tag><a href=/tags/react/>React</a>
</span><span class=separator>‚Ä¢</span>
<span class=tag><a href=/tags/frontend/>Frontend</a>
</span><span class=separator>‚Ä¢</span>
<span class=tag><a href=/tags/software-design/>Software Design</a></span></div></div></header><div class=post-content><p>In the Elm ecosystem, the browser is treated like an I/O device. DOM events, JavaScript interop, and even network requests are kept outside the core logic. Rather than allowing side effects to permeate the codebase, Elm channels them through strictly typed boundaries known as <em>ports</em>.</p><p>This architectural stance is both radical and liberating. It allows you to build user interfaces where logic remains pure, testable, and robust, even as surrounding technologies evolve.</p><p>You might not be writing Elm, but the core idea is portable: <strong>treat your UI runtime as a detail</strong>. What if React‚Äîor your TypeScript frontend‚Äîadopted this philosophy? What if we stopped treating our framework as the foundation and started treating it as just another dependency?</p><hr><h2 id=your-app-is-not-your-framework>Your App Is Not Your Framework
<a class=heading-link href=#your-app-is-not-your-framework><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Too many frontend projects blur the lines between business logic and UI behavior. It‚Äôs common to model domain concepts directly inside React components and tie state management logic to hooks, lifecycle events, or global stores.</p><p>Over time, this creates tight coupling to the framework. Refactoring becomes risky. Testing core logic without a UI becomes difficult. And your <em>business model</em> becomes tangled with the frontend library of the month.</p><p>You might discover, months in, that half your app is unusable outside a browser‚Äîor that important state transitions are buried deep inside components.</p><p><img src=https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExbWJocXQ3cnB5NG00OWV1aWZldmtvdjQxZmJxY3hiMndxcHJtZDNmYyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/SDGNkoOsb8alDk66ZN/giphy.gif alt=michael-scott-in-chains></p><p>According to Uncle Bob, you should <em>date</em> your framework, not <em>marry</em> it‚Äîand in theory, React isn‚Äôt even a framework, but a library. As Martin Fowler and others have pointed out, the key distinction lies in <em>inversion of control</em>: with a library, <em>your code</em> calls into it; with a framework, <em>it</em> calls into your code. This subtle but important difference affects how much architectural ownership you retain. As <a href=https://stackoverflow.com/questions/3057526/framework-vs-toolkit-vs-library class=external-link target=_blank rel=noopener>thoroughly explained and discussed here</a>, libraries are called by your code, while frameworks call your code.</p><p>By designing your application to live independently of its framework, you dramatically increase its adaptability and longevity.</p><h2 id=what-elm-gets-right>What Elm Gets Right
<a class=heading-link href=#what-elm-gets-right><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Elm enforces a clean separation of concerns from the start:</p><ul><li>UI updates are modeled as <strong>pure functions</strong></li><li>State transitions are explicit, driven by <strong>messages</strong></li><li>Side effects are expressed as <strong>commands</strong>, executed by the runtime</li><li>External interactions (e.g. JavaScript, local storage, sockets) go through <strong>ports</strong> with typed boundaries</li></ul><p>This structure makes Elm code surprisingly easy to reason about. Most files don‚Äôt even ‚Äúknow‚Äù the DOM exists. You test your business logic just as you would in a backend service.</p><p>Elm doesn‚Äôt just allow this separation‚Äîit <em>requires</em> it. That‚Äôs what gives Elm applications such strong architectural integrity.</p><p>And if a new JS feature becomes available, you can use it‚Äîjust on the <em>outside</em> of the port, treating it as implementation detail, not core logic.</p><h2 id=applying-the-same-mindset-in-reacttypescript>Applying the Same Mindset in React/TypeScript
<a class=heading-link href=#applying-the-same-mindset-in-reacttypescript><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>You don‚Äôt need to rewrite your app in Elm to benefit from this philosophy. Even in a conventional React/TypeScript stack, you can adopt many of the same patterns:</p><ol><li><strong>Keep domain logic in plain TypeScript modules.</strong> Avoid JSX or DOM references.</li><li><strong>Model UI state as a consequence of business state.</strong> Eliminate redundant local flags.</li><li><strong>Define ports explicitly.</strong> Side-effecting utilities like <code>copyToClipboard()</code> should live at the boundary.</li><li><strong>Test your logic in isolation.</strong> Leave UI interactions for the adapter layer.</li><li><strong>Establish clear boundaries.</strong> Name and document them like external APIs.</li></ol><p>In small apps, this might feel overengineered. But as complexity grows, the benefits compound. Debugging becomes easier. You can test without mocking every hook. You can reason clearly about behavior.</p><h2 id=a-boundary-buys-you-freedom>A Boundary Buys You Freedom
<a class=heading-link href=#a-boundary-buys-you-freedom><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>When your domain logic is independent of the DOM, you unlock powerful benefits:</p><ul><li>Share logic across platforms (web, native, CLI)</li><li>Run simulation tests without UI scaffolding</li><li>Swap out rendering libraries (React, Svelte, server-driven UI)</li><li>Move logic into backend tasks or scheduled jobs</li></ul><p>You also improve onboarding: new developers can focus on logic before touching the view layer.</p><p>A clear boundary keeps your app flexible, portable‚Äîand maintainable.</p><h2 id=the-stdinstdout-analogy>The STDIN/STDOUT Analogy
<a class=heading-link href=#the-stdinstdout-analogy><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In <em><a href=https://amzn.to/4iAc8o1 class=external-link target=_blank rel=noopener>Clean Architecture</a></em>, Uncle Bob recounts working on a payroll system whose logic was tightly coupled to its user interface and low-level I/O libraries. Initially, the system read data from punch cards and output to line printers. But as hardware evolved‚Äîmagnetic tapes, then disk storage, then terminals‚Äîeach shift in technology would have required major rewrites of the business logic.</p><p>To solve this, he redesigned the system to treat <code>STDIN</code> and <code>STDOUT</code> as abstraction boundaries. All input flowed through <code>STDIN</code>, all output through <code>STDOUT</code>. With this design, only the code that handled the I/O had to change when new hardware was introduced. The core logic remained untouched.</p><p>That insight‚Äîtreating delivery mechanisms as pluggable interfaces‚Äî<strong>is just as applicable to frontend development today</strong>. Browsers change, frameworks evolve, APIs deprecate. But if your business logic communicates with the runtime through clean ports, your application can stay stable through it all.</p><p><em>‚Äî Source: <a href=https://amzn.to/4iAc8o1 class=external-link target=_blank rel=noopener>Clean Architecture</a>, Robert C. Martin (2017)</em></p><h2 id=ports-are-more-than-just-interop>Ports Are More Than Just Interop
<a class=heading-link href=#ports-are-more-than-just-interop><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Elm uses the word <em>port</em> to describe the bridge between core logic and the wild and dangerous outside world that is JS (and manual DOM interaction). That linguistic choice matters.</p><p>If we start treating the DOM, browser APIs, and even JavaScript runtimes as <em>ports</em>‚Äînot as our app‚Äîwe‚Äôre more careful about where side effects live. We build a clean kernel of logic and wrap it in infrastructure.</p><p>Imagine treating the clipboard, URL bar, <code>localStorage</code>, or <code>window.location</code> as I/O devices rather than global state. The benefits are the same: modularity, testability, confidence.</p><p>This mindset isn‚Äôt exclusive to Elm. It belongs in every serious frontend codebase. And adopting it doesn‚Äôt mean switching languages‚Äîjust shifting how we define and respect our boundaries.</p></div><footer></footer></article></section></div><style>form{display:flex;justify-content:center}</style><form action="https://api.follow.it/subscription-form/SDRVMUk2VmsySENBNk94RDNKNDFnS3NmWlQ5a3gxejNIeUlJWHl3QjdqNnRHdENkaXp5aXZhZlFvcGtzcEZ3K0o5TFVRdSt2WWM5RWRsWmZwWVhNUS9PZjJqMWZ3aHBwZUhjT1ZpWXBGRkdZOWtIcGhYQkJkSkE4QTQ1eHl5YkF8RTZHTExQOWFrN1pFY1F0RzZ5c3pVN2I1QTI1YXNtMjZiYllLU25zQkJ3bz0=/8" method=post><input type=email name=email required placeholder=Email spellcheck=false style=padding:1rem;border:none;outline:none>
<button type=submit style=border:none;outline:none;background:#eee;cursor:pointer>
Subscribe</button></form><div id=elm-widget></div><script src=/widget.js></script><script>Elm.Main.init({node:document.getElementById("elm-widget"),flags:window.location.pathname})</script><script type=text/javascript src="https://platform-api.sharethis.com/js/sharethis.js#property=6834b86198608700128c9ffa&product=sticky-share-buttons" async></script><footer class=footer><section class=container>¬© 2021 - 2025 Christian Ekrem
<script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-emoji=üç∫ data-id=cekrem data-description="Support me on Buy me a coffee!" data-message data-color=#ddd data-position=Right data-x_margin=18 data-y_margin=18></script></section><script src=https://formspree.io/js/formbutton-v1.min.js defer></script></footer><script src=https://sdk.feedback.one/v0/core.min.js data-project-id=019589e0-c6fb-7b80-b6ae-dffbfbb11f72 defer></script></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script data-goatcounter=https://cekrem.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>