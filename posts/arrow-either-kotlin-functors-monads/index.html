<!doctype html><html lang=en><head><title>Arrow's Either: The Kotlin Chapter of our Scary Words Saga Â· cekrem.github.io</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Christian Ekrem"><meta name=description content="Taking our functor-applicative-monad tour from Elm to Kotlin, and discovering that Arrow has its own opinions about all this"><meta name=keywords content="developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cekrem.github.io/images/banner.jpg"><meta name=twitter:title content="Arrow's Either: The Kotlin Chapter of our Scary Words Saga"><meta name=twitter:description content="Taking our functor-applicative-monad tour from Elm to Kotlin, and discovering that Arrow has its own opinions about all this"><meta property="og:url" content="https://cekrem.github.io/posts/arrow-either-kotlin-functors-monads/"><meta property="og:site_name" content="cekrem.github.io"><meta property="og:title" content="Arrow's Either: The Kotlin Chapter of our Scary Words Saga"><meta property="og:description" content="Taking our functor-applicative-monad tour from Elm to Kotlin, and discovering that Arrow has its own opinions about all this"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-16T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-16T00:00:00+00:00"><meta property="article:tag" content="Kotlin"><meta property="article:tag" content="Functional Programming"><meta property="article:tag" content="Arrow"><meta property="article:tag" content="Tutorial"><meta property="og:image" content="https://cekrem.github.io/images/banner.jpg"><link rel=canonical href=https://cekrem.github.io/posts/arrow-either-kotlin-functors-monads/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.e8eb08b92eec0f2a19c8cbe4eda1f38c703416996d08f55900541ba798921e5b.css integrity="sha256-6OsIuS7sDyoZyMvk7aHzjHA0FpltCPVZAFQbp5iSHls=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a93347c2833a476d1c25ae74bed3f80024fc1eaf1a33d084c2211065513e5c42.css integrity="sha256-qTNHwoM6R20cJa50vtP4ACT8Hq8aM9CEwiEQZVE+XEI=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://cekrem.github.io/>cekrem.github.io
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/how-i-met-jesus/>Jesus!?</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/books-i-think-software-engineers-should-read>Recommended Books</a></li><li class=navigation-item><a class=navigation-link href=https://creators.spotify.com/pod/show/disippel>Podcast (ðŸ‡³ðŸ‡´)</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://cekrem.github.io/posts/arrow-either-kotlin-functors-monads/>Arrow's Either: The Kotlin Chapter of our Scary Words Saga</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2026-01-16T00:00:00Z>January 16, 2026
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
7-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/kotlin/>Kotlin</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/functional-programming/>Functional Programming</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/arrow/>Arrow</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/tutorial/>Tutorial</a></span></div></div></header><div class=post-content><h2 id=previously-on-scary-words>Previously, on &ldquo;Scary Words&rdquo;
<a class=heading-link href=#previously-on-scary-words><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>A few weeks back I wrote about <a href=/posts/functors-applicatives-monads-elm/>functors, applicatives, and monads in Elm</a> â€“ those three terrifying terms that make developers&rsquo; eyes glaze over. The punchline was simple: if you&rsquo;ve used <code>map</code>, <code>map2</code>, or <code>andThen</code>, you already know these concepts. You just didn&rsquo;t know they had fancy names.</p><p>But here&rsquo;s the thing: I spend a lot of my day-to-day in Kotlin, not Elm. And Kotlin has its own functional programming story, largely thanks to a library called <a href=https://arrow-kt.io/ class=external-link target=_blank rel=noopener>Arrow</a>. So I thought it&rsquo;d be fun to see how the same concepts translate.</p><p>Spoiler: they translate <em>pretty well</em>, but Arrow has made some interesting choices along the way.</p><h2 id=either-the-result-type-you-wished-you-had>Either: The Result Type You Wished You Had
<a class=heading-link href=#either-the-result-type-you-wished-you-had><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>If you&rsquo;re coming from Elm, think of Arrow&rsquo;s <code>Either&lt;E, A></code> as basically <code>Result&lt;Error, Value></code> with a different name. It&rsquo;s a container that holds <em>either</em> a &ldquo;left&rdquo; value (conventionally the error) or a &ldquo;right&rdquo; value (the success). Yes, &ldquo;right&rdquo; as in &ldquo;correct.&rdquo; Functional programmers love their puns.</p><p>(F# decided to put the success type <em>first</em> in their <code>Result&lt;'T, 'TError></code>, completely ruining the pun. Typical.)</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>import</span> arrow.core.Either
</span></span><span style=display:flex><span><span style=color:#ff6ac1>import</span> arrow.core.left
</span></span><span style=display:flex><span><span style=color:#ff6ac1>import</span> arrow.core.right
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// A successful value
</span></span></span><span style=display:flex><span><span style=color:#ff6ac1>val</span> userName: Either&lt;String, String&gt; = <span style=color:#5af78e>&#34;Christian&#34;</span>.right()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// An error
</span></span></span><span style=display:flex><span><span style=color:#ff6ac1>val</span> userAge: Either&lt;String, Int&gt; = <span style=color:#5af78e>&#34;Age cannot be negative&#34;</span>.left()
</span></span></code></pre></div><p>Why <code>Either</code> instead of Kotlin&rsquo;s built-in <code>Result</code>? Well, <code>Result</code> is designed primarily for catching exceptions, and it bakes in <code>Throwable</code> as the error type. <code>Either</code> is more flexible â€“ your &ldquo;left&rdquo; can be whatever you want: a string, a sealed class of domain errors, an enum. In practice, this matters <em>a lot</em> for modeling business logic.</p><h2 id=functor-yes-it-maps>Functor: Yes, It Maps
<a class=heading-link href=#functor-yes-it-maps><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Remember our definition from the Elm post? A functor is anything you can <code>map</code> over. You have a value in a container, you want to apply a function without unwrapping.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#78787e>// Apply a function to a wrapped value
</span></span></span><span style=display:flex><span><span style=color:#5af78e>&#34;hello&#34;</span>.right().map { <span style=color:#ff6ac1>it</span>.uppercase() }  <span style=color:#78787e>// Either.Right(&#34;HELLO&#34;)
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#5af78e>&#34;oops&#34;</span>.left().map { <span style=color:#ff6ac1>it</span>.uppercase() }    <span style=color:#78787e>// Either.Left(&#34;oops&#34;) - untouched!
</span></span></span></code></pre></div><p>That&rsquo;s it. <code>Either</code> is a functor. If the value is <code>Right</code>, the function runs. If it&rsquo;s <code>Left</code>, nothing happens â€“ the error just passes through. Same pattern as <code>Maybe.map</code> in Elm, just with <code>Right</code>/<code>Left</code> instead of <code>Just</code>/<code>Nothing</code>.</p><p>Arrow also gives you <code>mapLeft</code> for when you want to transform the error side:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#5af78e>&#34;oops&#34;</span>.left().mapLeft { <span style=color:#5af78e>&#34;Error: </span><span style=color:#5af78e>$it</span><span style=color:#5af78e>&#34;</span> }  <span style=color:#78787e>// Either.Left(&#34;Error: oops&#34;)
</span></span></span></code></pre></div><p>Handy for error translation between layers of your app.</p><h2 id=applicative-combining-multiple-eithers>Applicative: Combining Multiple Eithers
<a class=heading-link href=#applicative-combining-multiple-eithers><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Here&rsquo;s where it gets interesting. Remember the applicative problem? You have a function that takes multiple arguments, and multiple wrapped values:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>data</span> <span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>User</span>(<span style=color:#ff6ac1>val</span> name: String, <span style=color:#ff6ac1>val</span> age: Int, <span style=color:#ff6ac1>val</span> email: String)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>validName</span>(name: String): Either&lt;String, String&gt; =
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>if</span> (name.isNotBlank()) name.right() <span style=color:#ff6ac1>else</span> <span style=color:#5af78e>&#34;Name required&#34;</span>.left()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>validAge</span>(age: Int): Either&lt;String, Int&gt; =
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>if</span> (age <span style=color:#ff6ac1>in</span> <span style=color:#ff9f43>1</span><span style=color:#ff6ac1>..</span><span style=color:#ff9f43>149</span>) age.right() <span style=color:#ff6ac1>else</span> <span style=color:#5af78e>&#34;Invalid age&#34;</span>.left()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>validEmail</span>(email: String): Either&lt;String, String&gt; =
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>if</span> (email.contains(<span style=color:#5af78e>&#34;@&#34;</span>)) email.right() <span style=color:#ff6ac1>else</span> <span style=color:#5af78e>&#34;Invalid email&#34;</span>.left()
</span></span></code></pre></div><p>In Elm, you&rsquo;d use <code>Result.map3 User validName validAge validEmail</code>. In Arrow, the idiomatic way is to use <code>bind()</code> inside an <code>either { }</code> block:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>import</span> arrow.core.raise.either
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// Short-circuit on first error (like Elm)
</span></span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>createUser</span>(name: String, age: Int, email: String): Either&lt;String, User&gt; = either {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> n = validName(name).bind()
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> a = validAge(age).bind()
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> e = validEmail(email).bind()
</span></span><span style=display:flex><span>    User(n, a, e)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But wait â€“ what if you want to collect <em>all</em> the errors instead of stopping at the first one? This is where Arrow gets opinionated.</p><h3 id=the-error-accumulation-question>The Error Accumulation Question
<a class=heading-link href=#the-error-accumulation-question><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Here&rsquo;s a choice you don&rsquo;t face in Elm: when combining multiple operations that might fail, what happens if <em>several</em> of them fail?</p><p>Elm&rsquo;s <code>Result.map3</code> short-circuits on the first error. Arrow gives you both options via <code>zipOrAccumulate</code>:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#78787e>// Accumulate: collects ALL errors
</span></span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>createUserAccumulating</span>(
</span></span><span style=display:flex><span>    name: String,
</span></span><span style=display:flex><span>    age: Int,
</span></span><span style=display:flex><span>    email: String
</span></span><span style=display:flex><span>): Either&lt;NonEmptyList&lt;String&gt;, User&gt; = either {
</span></span><span style=display:flex><span>    zipOrAccumulate(
</span></span><span style=display:flex><span>        { validName(name).bind() },
</span></span><span style=display:flex><span>        { validAge(age).bind() },
</span></span><span style=display:flex><span>        { validEmail(email).bind() }
</span></span><span style=display:flex><span>    ) { n, a, e <span style=color:#ff6ac1>-&gt;</span> User(n, a, e) }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// If name is blank AND email is invalid:
</span></span></span><span style=display:flex><span><span style=color:#78787e>// Either.Left(NonEmptyList(&#34;Name required&#34;, &#34;Invalid email&#34;))
</span></span></span></code></pre></div><p>(Yes, those curly braces around each validation look a bit weird â€“ that&rsquo;s just how Kotlin&rsquo;s lambda syntax works with multiple arguments. You get used to it.)</p><p>This is genuinely useful for form validation â€“ you probably want to show all the problems at once, not play whack-a-mole with the user. But it&rsquo;s also a choice you need to <em>make</em>, which adds cognitive overhead. Elm sidesteps this entirely by always short-circuiting. Different philosophy.</p><h2 id=monad-the-flatmapbind-chapter>Monad: The flatMap/bind Chapter
<a class=heading-link href=#monad-the-flatmapbind-chapter><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>And now, the M-word. Same scenario as the Elm post: you have a wrapped value, and a function that <em>returns</em> a wrapped value. Without special handling, you&rsquo;d get <code>Either&lt;E, Either&lt;E, A>></code> â€“ nested containers. Nobody wants that.</p><p>In Elm, this is <code>andThen</code>. In Arrow, it&rsquo;s <code>flatMap</code>:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>parseAge</span>(str: String): Either&lt;String, Int&gt; =
</span></span><span style=display:flex><span>    str.toIntOrNull()<span style=color:#ff6ac1>?.</span>right()
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>?:</span> <span style=color:#5af78e>&#34;Not a valid number&#34;</span>.left()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>validateAge</span>(age: Int): Either&lt;String, Int&gt; =
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>if</span> (age <span style=color:#ff6ac1>in</span> <span style=color:#ff9f43>1</span><span style=color:#ff6ac1>..</span><span style=color:#ff9f43>149</span>) age.right()
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>else</span> <span style=color:#5af78e>&#34;Age must be between 1 and 149&#34;</span>.left()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// Chain operations that might fail
</span></span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>processAge</span>(input: String): Either&lt;String, Int&gt; =
</span></span><span style=display:flex><span>    parseAge(input).flatMap { validateAge(<span style=color:#ff6ac1>it</span>) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>processAge(<span style=color:#5af78e>&#34;42&#34;</span>)   <span style=color:#78787e>// Either.Right(42)
</span></span></span><span style=display:flex><span>processAge(<span style=color:#5af78e>&#34;abc&#34;</span>)  <span style=color:#78787e>// Either.Left(&#34;Not a valid number&#34;)
</span></span></span><span style=display:flex><span>processAge(<span style=color:#5af78e>&#34;-5&#34;</span>)   <span style=color:#78787e>// Either.Left(&#34;Age must be between 1 and 149&#34;)
</span></span></span></code></pre></div><p>Same pattern as <code>Result.andThen</code> in Elm. The nesting problem never materializes because <code>flatMap</code> handles the unwrapping.</p><h2 id=the-either---block-arrows-secret-weapon>The either { } Block: Arrow&rsquo;s Secret Weapon
<a class=heading-link href=#the-either---block-arrows-secret-weapon><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Here&rsquo;s something Elm <em>can&rsquo;t</em> do (by design): Arrow lets you write imperative-looking code that&rsquo;s actually monadic under the hood. (We actually already saw this above, but let&rsquo;s break it down.)</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>import</span> arrow.core.raise.either
</span></span><span style=display:flex><span><span style=color:#ff6ac1>import</span> arrow.core.raise.zipOrAccumulate
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>createUser</span>(
</span></span><span style=display:flex><span>    nameInput: String,
</span></span><span style=display:flex><span>    ageInput: String,
</span></span><span style=display:flex><span>    emailInput: String
</span></span><span style=display:flex><span>): Either&lt;String, User&gt; = either {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> name = validateName(nameInput).bind()
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> age = parseAge(ageInput).bind()
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> validAge = validateAge(age).bind()
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> email = validateEmail(emailInput).bind()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    User(name, validAge, email)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That <code>bind()</code> call is basically <code>andThen</code> in disguise. If any <code>bind()</code> hits a <code>Left</code>, the whole block short-circuits and returns that error. But it <em>reads</em> like straight-line imperative code.</p><p>Is this cheating? Kinda! It&rsquo;s using Kotlin&rsquo;s coroutine machinery to fake early returns. Elm would never do this â€“ the whole point of Elm is that effects are <em>always</em> explicit in the type signatures, and control flow is <em>always</em> visible.</p><p>But honestly? For complex validation chains in Kotlin, this is really nice to write. I&rsquo;ve used it plenty. The pragmatist in me wins over the purist here. Â¯\_(ãƒ„)_/Â¯</p><h2 id=so-is-either-a-real-monad>So Is Either a &ldquo;Real&rdquo; Monad?
<a class=heading-link href=#so-is-either-a-real-monad><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Yes! <code>Either</code> satisfies the monad laws:</p><ol><li><strong>Left identity</strong>: <code>a.right().flatMap(f)</code> equals <code>f(a)</code></li><li><strong>Right identity</strong>: <code>m.flatMap { it.right() }</code> equals <code>m</code></li><li><strong>Associativity</strong>: <code>m.flatMap(f).flatMap(g)</code> equals <code>m.flatMap { f(it).flatMap(g) }</code></li></ol><p>Arrow used to have explicit <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> type classes (like Haskell), but they removed them in Arrow 1.x. Now it&rsquo;s all just extension functions on the types themselves. Less abstract, more pragmatic â€“ a bit like Elm&rsquo;s philosophy, actually.</p><p>The Arrow team&rsquo;s reasoning: Kotlin&rsquo;s type system can&rsquo;t express higher-kinded types elegantly, so the type class approach was always fighting the language. Better to just give you the functions you need directly.</p><h2 id=the-comparison-table>The Comparison Table
<a class=heading-link href=#the-comparison-table><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><table><thead><tr><th>Concept</th><th>Elm</th><th>Kotlin/Arrow</th><th>Haskell</th></tr></thead><tbody><tr><td>Functor</td><td><code>Result.map</code></td><td><code>Either.map</code></td><td><code>fmap</code> / <code>&lt;$></code></td></tr><tr><td>Applicative</td><td><code>Result.map2</code>, <code>map3</code>&mldr;</td><td><code>zipOrAccumulate</code></td><td><code>&lt;*></code></td></tr><tr><td>Monad</td><td><code>Result.andThen</code></td><td><code>Either.flatMap</code>, <code>bind()</code></td><td><code>>>=</code> (bind)</td></tr></tbody></table><p>Same patterns, different spellings.</p><h2 id=the-takeaway>The Takeaway
<a class=heading-link href=#the-takeaway><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>If you&rsquo;ve used <code>map</code>, <code>flatMap</code>, and <code>bind()</code> on Arrow&rsquo;s <code>Either</code>, congratulations â€“ you&rsquo;ve been writing functorial, applicative, and monadic code. The scary words are just labels for the patterns you&rsquo;re already using.</p><p>Arrow&rsquo;s approach is more flexible than Elm&rsquo;s (error accumulation! imperative syntax!) but that flexibility comes with choices. Elm says &ldquo;here&rsquo;s the one way to do it.&rdquo; Arrow says &ldquo;here are several ways, pick what fits.&rdquo;</p><p>Neither is wrong. Elm optimizes for simplicity and learnability. Arrow optimizes for power and flexibility in a language (Kotlin) that already embraces multiple paradigms.</p><p>The real lesson? These patterns are <em>universal</em>. Whether you&rsquo;re writing Elm, Kotlin, Haskell, TypeScript, Rust, or whatever comes next â€“ you&rsquo;ll find functors, applicatives, and monads lurking there, possibly wearing different names.</p><p>And now you know them by all their aliases.</p><hr><p><em>If you missed the first part, check out <a href=/posts/functors-applicatives-monads-elm/>Functors, Applicatives, and Monads: The Scary Words You Already Understand</a> for the Elm perspective. And if you&rsquo;re curious about Arrow, their <a href=https://arrow-kt.io/learn/typed-errors/working-with-typed-errors/ class=external-link target=_blank rel=noopener>official docs</a> are surprisingly readable â€“ no category theory degree required.</em></p></div><footer></footer></article></section></div><style>form{display:flex;justify-content:center}</style><form action="https://api.follow.it/subscription-form/SDRVMUk2VmsySENBNk94RDNKNDFnS3NmWlQ5a3gxejNIeUlJWHl3QjdqNnRHdENkaXp5aXZhZlFvcGtzcEZ3K0o5TFVRdSt2WWM5RWRsWmZwWVhNUS9PZjJqMWZ3aHBwZUhjT1ZpWXBGRkdZOWtIcGhYQkJkSkE4QTQ1eHl5YkF8RTZHTExQOWFrN1pFY1F0RzZ5c3pVN2I1QTI1YXNtMjZiYllLU25zQkJ3bz0=/8" method=post onsubmit=onSubscribe()><input type=email name=email required placeholder=Email spellcheck=false style="padding:1rem;border:none;border-radius:1rem 0 0 1rem;outline:none">
<button type=submit style="border:none;border-radius:0 1rem 1rem 0;outline:none;background:rgba(127,127,127,5%);cursor:pointer">
Subscribe</button></form><div id=elm-widget></div><script src=/widget.js></script><script>Elm.Main.init({node:document.getElementById("elm-widget"),flags:window.location.pathname})</script><script type=text/javascript src="https://platform-api.sharethis.com/js/sharethis.js#property=6834b86198608700128c9ffa&product=sticky-share-buttons" async></script><footer class=footer><section class=container>Â© 2021 - 2026 Christian Ekrem
<script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-emoji=ðŸº data-id=cekrem data-description="Support me on Buy me a coffee!" data-message data-color=#ddd data-position=Left data-x_margin=18 data-y_margin=18></script></section><script src=https://formspree.io/js/formbutton-v1.min.js defer></script></footer><script src=https://sdk.feedback.one/v0/core.min.js data-project-id=019589e0-c6fb-7b80-b6ae-dffbfbb11f72 defer></script><script>!function(e,t){var n,s,o,i;t.__SV||window.posthog&&window.posthog.__loaded||(window.posthog=t,t._i=[],t.init=function(a,r,c){function d(e,t){var n=t.split(".");2==n.length&&(e=e[n[0]],t=n[1]),e[t]=function(){e.push([t].concat(Array.prototype.slice.call(arguments,0)))}}(n=e.createElement("script")).type="text/javascript",n.crossOrigin="anonymous",n.async=!0,n.src=r.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(i=e.getElementsByTagName("script")[0]).parentNode.insertBefore(n,i);var l=t;for(0[0]!==c?l=t[c]=[]:c="posthog",l.people=l.people||[],l.toString=function(e){var t="posthog";return"posthog"!==c&&(t+="."+c),e||(t+=" (stub)"),t},l.people.toString=function(){return l.toString(1)+".people (stub)"},o="init Rr Mr fi Or Ar ci Tr Cr capture Mi calculateEventProperties Lr register register_once register_for_session unregister unregister_for_session Hr getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey displaySurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty Ur jr createPersonProfile zr kr Br opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing get_explicit_consent_status is_capturing clear_opt_in_out_capturing Dr debug M Nr getPageViewId captureTraceFeedback captureTraceMetric $r".split(" "),s=0;s<o.length;s++)d(l,o[s]);t._i.push([a,r,c])},t.__SV=1)}(document,window.posthog||[]),posthog.init("phc_AHy7NSMntJJLr0hUSCwdUS1eRq6SaEqacK1Mzzf36ED",{api_host:"https://eu.i.posthog.com",defaults:"2025-05-24",person_profiles:"identified_only"});function onSubscribe(){posthog.capture("new subscriber")}</script></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script data-goatcounter=https://cekrem.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>