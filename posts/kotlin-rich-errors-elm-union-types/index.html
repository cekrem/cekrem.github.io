<!doctype html><html lang=en><head><title>Kotlin's Rich Errors: Native, Typed Errors Without Exceptions · cekrem.github.io</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Christian Ekrem"><meta name=description content="At KotlinConf 2025, the Kotlin team showcased progress toward Rich Errors with union types. After years of watching languages slowly adopt patterns that Elm has championed since day one, it&rsquo;s exciting to see Kotlin taking this significant step toward more explicit, type-safe error handling. And in a very &ldquo;native&rdquo; Kotlin way at that!
I vividly remember this announcement giving my functional heart a pleasant jolt, but I haven&rsquo;t found the time for a write-up until now. Better late than never, though:"><meta name=keywords content="developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cekrem.github.io/images/featured-with-margins.png"><meta name=twitter:title content="Kotlin's Rich Errors: Native, Typed Errors Without Exceptions"><meta name=twitter:description content="At KotlinConf 2025, the Kotlin team showcased progress toward Rich Errors with union types. After years of watching languages slowly adopt patterns that Elm has championed since day one, it’s exciting to see Kotlin taking this significant step toward more explicit, type-safe error handling. And in a very “native” Kotlin way at that!
I vividly remember this announcement giving my functional heart a pleasant jolt, but I haven’t found the time for a write-up until now. Better late than never, though:"><meta property="og:url" content="https://cekrem.github.io/posts/kotlin-rich-errors-elm-union-types/"><meta property="og:site_name" content="cekrem.github.io"><meta property="og:title" content="Kotlin's Rich Errors: Native, Typed Errors Without Exceptions"><meta property="og:description" content="At KotlinConf 2025, the Kotlin team showcased progress toward Rich Errors with union types. After years of watching languages slowly adopt patterns that Elm has championed since day one, it’s exciting to see Kotlin taking this significant step toward more explicit, type-safe error handling. And in a very “native” Kotlin way at that!
I vividly remember this announcement giving my functional heart a pleasant jolt, but I haven’t found the time for a write-up until now. Better late than never, though:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-08T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-08T00:00:00+00:00"><meta property="article:tag" content="Kotlin"><meta property="article:tag" content="Elm"><meta property="article:tag" content="Arrow"><meta property="article:tag" content="Functional Programming"><meta property="article:tag" content="Error-Handling"><meta property="article:tag" content="Union-Types"><meta property="og:image" content="https://cekrem.github.io/images/featured-with-margins.png"><link rel=canonical href=https://cekrem.github.io/posts/kotlin-rich-errors-elm-union-types/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.f63b17f16aa5dbf557dd08e6806b0b477d5e6d8f2af64807e14512a12dd2ccaa.css integrity="sha256-9jsX8Wql2/VX3QjmgGsLR31ebY8q9kgH4UUSoS3SzKo=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.be284be20943b01514c49cbe3832fe8cc215513c0e5962b1d349102cf16f2c25.css integrity="sha256-vihL4glDsBUUxJy+ODL+jMIVUTwOWWKx00kQLPFvLCU=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://cekrem.github.io/>cekrem.github.io
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/hire/>Hire me?</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/books-i-think-software-engineers-should-read>Recommended Books</a></li><li class=navigation-item><a class=navigation-link href=https://creators.spotify.com/pod/show/disippel>Podcast (🇳🇴)</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://cekrem.github.io/posts/kotlin-rich-errors-elm-union-types/>Kotlin's Rich Errors: Native, Typed Errors Without Exceptions</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-08-08T00:00:00Z>August 8, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
4-minute read</span></div><div class=categories><i class="fa-solid fa-folder" aria-hidden=true></i>
<a href=/categories/programming/>Programming</a>
<span class=separator>•</span>
<a href=/categories/kotlin/>Kotlin</a>
<span class=separator>•</span>
<a href=/categories/functional-programming/>Functional Programming</a>
<span class=separator>•</span>
<a href=/categories/rich-errors/>Rich Errors</a></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/kotlin/>Kotlin</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/elm/>Elm</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/arrow/>Arrow</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/functional-programming/>Functional Programming</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/error-handling/>Error-Handling</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/union-types/>Union-Types</a></span></div></div></header><div class=post-content><p>At KotlinConf 2025, the Kotlin team showcased progress toward <strong>Rich Errors</strong> with union types. After years of watching languages slowly adopt patterns that Elm has championed since day one, it&rsquo;s exciting to see Kotlin taking this significant step toward more explicit, type-safe error handling. And in a very &ldquo;native&rdquo; Kotlin way at that!</p><p>I vividly remember this announcement giving my functional heart a pleasant jolt, but I haven&rsquo;t found the time for a write-up until now. Better late than never, though:</p><h2 id=what-are-rich-errors-in-kotlin>What Are Rich Errors in Kotlin?
<a class=heading-link href=#what-are-rich-errors-in-kotlin><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Kotlin&rsquo;s Rich Errors feature introduces union types specifically for error handling, allowing functions to return values like <code>String | Error</code> - a type that can be either a <code>String</code> or an <code>Error</code>. This is a fundamental shift away from the traditional try-catch paradigm toward explicit, type-safe error handling.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#78787e>// Future Kotlin with Rich Errors
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>parseNumber</span>(input: String): Int | ParseError {
</span></span><span style=display:flex><span>    <span style=color:#78787e>// Returns either an Int or a ParseError
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>}
</span></span></code></pre></div><p>This approach makes errors part of the type system, forcing developers to handle them explicitly rather than hoping they remember to wrap everything in try-catch blocks.</p><h3 id=how-this-compares-in-kotlin-today>How this compares in Kotlin today
<a class=heading-link href=#how-this-compares-in-kotlin-today><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Kotlin already ships with <code>Result&lt;T></code> in the standard library, and many teams model error domains with Arrow&rsquo;s <code>Either&lt;Error, Value></code>/<code>Validated</code>. Rich Errors make these patterns feel native: the error space becomes part of the function type without wrappers. This reduces the need for <code>Either</code>-style constructs for many cases, while Arrow still remains valuable for optics, typed effects, and broader FP utilities.</p><h2 id=familiar-pattern-in-other-ecosystems>Familiar pattern in other ecosystems
<a class=heading-link href=#familiar-pattern-in-other-ecosystems><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>If you&rsquo;ve used languages or libraries that embrace typed errors, the idea will feel familiar: Elm&rsquo;s <code>Result</code> (and to some extent <code>Maybe</code>), Rust&rsquo;s <code>Result&lt;T, E></code>, Swift&rsquo;s <code>Result&lt;Success, Failure></code>, or Kotlin&rsquo;s Arrow <code>Either</code>. Rich Errors bring this experience directly into Kotlin&rsquo;s type system.</p><h2 id=why-this-matters>Why This Matters
<a class=heading-link href=#why-this-matters><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=type-safety-over-runtime-surprises>Type Safety Over Runtime Surprises
<a class=heading-link href=#type-safety-over-runtime-surprises><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Traditional exception-based error handling in languages like Java and Kotlin (pre-rich errors) suffers from a fundamental problem: exceptions are invisible in the type system. You can&rsquo;t tell from a function signature whether it throws exceptions or what kinds of exceptions to expect.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#78787e>// Traditional Kotlin - what exceptions might this throw?
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>parseNumber</span>(input: String): Int {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>return</span> input.toInt() <span style=color:#78787e>// NumberFormatException? Who knows!
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>}
</span></span></code></pre></div><p>With union types, errors become explicit:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#78787e>// Rich Errors Kotlin - crystal clear what can go wrong
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>parseNumber</span>(input: String): Int | ParseError
</span></span></code></pre></div><h3 id=performance-benefits>Performance Benefits
<a class=heading-link href=#performance-benefits><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Exception handling has runtime overhead. Creating stack traces, unwinding the call stack, and throwing exceptions all cost CPU cycles. Union-like typed errors are just regular values—no special runtime machinery required.</p><h3 id=composability>Composability
<a class=heading-link href=#composability><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>When errors are values, composition and transformation flow naturally. Mapping, flat-mapping, and aggregating error-aware computations become straightforward and explicit, without exceptions jumping across call sites.</p><h2 id=the-road-ahead>The Road Ahead
<a class=heading-link href=#the-road-ahead><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Kotlin&rsquo;s Rich Errors feature is under active design and currently experimental; details, syntax, and operator semantics may change. The intent is to cover many use cases currently handled by wrappers like <code>Either</code> or <code>Result</code>; whether it fully replaces them will depend on the final design and ecosystem adoption. As a built-in construct, it could be more efficient and convenient than library-based solutions. For the latest status, see the official Kotlin page for language features and proposals: <a href=https://kotlinlang.org/docs/kotlin-language-features-and-proposals.html class=external-link target=_blank rel=noopener>Kotlin language features and proposals</a>.</p><h2 id=key-benefits>Key benefits
<a class=heading-link href=#key-benefits><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ol><li><strong>Exhaustiveness enforced</strong>: the compiler keeps success and error paths explicit</li><li><strong>Composable control flow</strong>: map/flatMap-style composition without exceptions</li><li><strong>Predictability</strong>: fewer hidden control transfers from thrown exceptions</li><li><strong>Safer refactors</strong>: changing error types surfaces all impacted call sites</li></ol><h2 id=looking-forward>Looking Forward
<a class=heading-link href=#looking-forward><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>For teams already using Arrow or similar libraries, this direction validates your emphasis on typed errors while promising a more idiomatic, built-in experience over time.</p><p>The fact that Kotlin is moving in this direction suggests we&rsquo;re approaching a tipping point where explicit error handling becomes the norm rather than the exception (pun intended). And honestly, it&rsquo;s about time.</p><hr><h3 id=further-reading>Further reading
<a class=heading-link href=#further-reading><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li>Official status and proposals: <a href=https://kotlinlang.org/docs/kotlin-language-features-and-proposals.html class=external-link target=_blank rel=noopener>Kotlin language features and proposals</a></li></ul></div><footer></footer></article></section></div><style>form{display:flex;justify-content:center}</style><form action="https://api.follow.it/subscription-form/SDRVMUk2VmsySENBNk94RDNKNDFnS3NmWlQ5a3gxejNIeUlJWHl3QjdqNnRHdENkaXp5aXZhZlFvcGtzcEZ3K0o5TFVRdSt2WWM5RWRsWmZwWVhNUS9PZjJqMWZ3aHBwZUhjT1ZpWXBGRkdZOWtIcGhYQkJkSkE4QTQ1eHl5YkF8RTZHTExQOWFrN1pFY1F0RzZ5c3pVN2I1QTI1YXNtMjZiYllLU25zQkJ3bz0=/8" method=post><input type=email name=email required placeholder=Email spellcheck=false style="padding:1rem;border:none;border-radius:1rem 0 0 1rem;outline:none">
<button type=submit style="border:none;border-radius:0 1rem 1rem 0;outline:none;background:rgba(127,127,127,5%);cursor:pointer">
Subscribe</button></form><div id=elm-widget></div><script src=/widget.js></script><script>Elm.Main.init({node:document.getElementById("elm-widget"),flags:window.location.pathname})</script><script type=text/javascript src="https://platform-api.sharethis.com/js/sharethis.js#property=6834b86198608700128c9ffa&product=sticky-share-buttons" async></script><footer class=footer><section class=container>© 2021 - 2025 Christian Ekrem
<script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-emoji=🍺 data-id=cekrem data-description="Support me on Buy me a coffee!" data-message data-color=#ddd data-position=Left data-x_margin=18 data-y_margin=18></script></section><script src=https://formspree.io/js/formbutton-v1.min.js defer></script></footer><script src=https://sdk.feedback.one/v0/core.min.js data-project-id=019589e0-c6fb-7b80-b6ae-dffbfbb11f72 defer></script></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script data-goatcounter=https://cekrem.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>