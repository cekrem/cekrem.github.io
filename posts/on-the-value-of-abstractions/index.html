<!doctype html><html lang=en><head><title>On the Value of Abstractions · cekrem.github.io</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Christian Ekrem"><meta name=description content="A reflection on why starting with abstractions—even simple ones—pays off in real-world development."><meta name=keywords content="developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cekrem.github.io/images/featured-with-margins.png"><meta name=twitter:title content="On the Value of Abstractions"><meta name=twitter:description content="A reflection on why starting with abstractions—even simple ones—pays off in real-world development."><meta property="og:url" content="https://cekrem.github.io/posts/on-the-value-of-abstractions/"><meta property="og:site_name" content="cekrem.github.io"><meta property="og:title" content="On the Value of Abstractions"><meta property="og:description" content="A reflection on why starting with abstractions—even simple ones—pays off in real-world development."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-07T00:00:00+00:00"><meta property="article:modified_time" content="2025-08-07T00:00:00+00:00"><meta property="article:tag" content="Architecture"><meta property="article:tag" content="Kotlin"><meta property="article:tag" content="Elm"><meta property="article:tag" content="Software-Design"><meta property="og:image" content="https://cekrem.github.io/images/featured-with-margins.png"><link rel=canonical href=https://cekrem.github.io/posts/on-the-value-of-abstractions/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0be07cbe43dba3fa453dd30d5e061a4931b10e5b391f3ea77262bb86ffc94b4d.css integrity="sha256-C+B8vkPbo/pFPdMNXgYaSTGxDls5Hz6ncmK7hv/JS00=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.be284be20943b01514c49cbe3832fe8cc215513c0e5962b1d349102cf16f2c25.css integrity="sha256-vihL4glDsBUUxJy+ODL+jMIVUTwOWWKx00kQLPFvLCU=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://cekrem.github.io/>cekrem.github.io
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/hire/>Hire me?</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/books-i-think-software-engineers-should-read>Recommended Books</a></li><li class=navigation-item><a class=navigation-link href=https://creators.spotify.com/pod/show/disippel>Podcast (🇳🇴)</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://cekrem.github.io/posts/on-the-value-of-abstractions/>On the Value of Abstractions</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-08-07T00:00:00Z>August 7, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
4-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/architecture/>Architecture</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/kotlin/>Kotlin</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/elm/>Elm</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/software-design/>Software-Design</a></span></div></div></header><div class=post-content><p>Most of my day-to-day work is in Elm. The combination of a functional language and the Elm Architecture makes many architectural decisions almost invisible (I talk more about that <a href=/posts/why-i-hope-i-get-to-write-a-lot-of-elm-code-in-2025/#the-elm-architecture-vs-clean-architecture>in this blog post</a>). You get a clear separation of concerns, and the language nudges you toward good design by default.</p><p>But my work isn’t limited to Elm. I frequently find myself building features that span both frontend and backend—writing new endpoints, and sometimes even designing new database tables. When I step outside the Elm world, I’m reminded that architecture is something I have to be intentional about again.</p><p>This post isn’t about which code goes in which layer, or about specific design patterns. Instead, I want to zoom in on a deceptively simple choice: should you just implement the thing you need, or should you start by carving out an abstraction?</p><p>I’ll argue that starting with an abstraction pays off, even when it feels like extra work.</p><p>Let’s take a concrete example. Suppose I need a <code>SearchCacheRepository</code>—something to store and retrieve cached search results. I could just write a class that does what I need, jumping straight to creating the appropriate tables (and indices) and call it a day. But instead, I find myself reaching for an interface:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff9f43>@ImplementedBy</span>(SearchCacheInMemoryImpl<span style=color:#ff6ac1>::</span><span style=color:#ff6ac1>class</span>)
</span></span><span style=display:flex><span><span style=color:#ff6ac1>interface</span> <span style=color:#f3f99d>SearchCacheRepository</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>val</span> cacheTimeout: Duration
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>suspend</span> <span style=color:#ff6ac1>fun</span> <span style=color:#57c7ff>getCachedSearch</span>(
</span></span><span style=display:flex><span>        userID: Int,
</span></span><span style=display:flex><span>        searchId: String,
</span></span><span style=display:flex><span>    ): Either&lt;CacheError, CachedSearch&gt;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And then, I’ll write a quick in-memory implementation:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff9f43>@Singleton</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>SearchCacheInMemoryImpl</span> : SearchCacheRepository {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>val</span> cacheTimeout = <span style=color:#ff9f43>10.</span>seconds
</span></span><span style=display:flex><span>    <span style=color:#78787e>// Implementation using hashMap follows
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>}
</span></span></code></pre></div><p>Later, when I need to actually persist things, I can add a SQL-backed implementation:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff9f43>@Singleton</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>class</span> <span style=color:#f3f99d>SearchCacheSqlImpl</span>
</span></span><span style=display:flex><span><span style=color:#ff9f43>@Inject</span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>constructor</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>private</span> <span style=color:#ff6ac1>val</span> dbProvider: DatasourceProvider,
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>override</span> <span style=color:#ff6ac1>val</span> cacheTimeout: Duration
</span></span><span style=display:flex><span>) : SearchCacheRepository {
</span></span><span style=display:flex><span>    <span style=color:#78787e>// Implementation using Postgres or whatever follows
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>}
</span></span></code></pre></div><h2 id=why-bother-with-the-abstraction>Why Bother With the Abstraction?
<a class=heading-link href=#why-bother-with-the-abstraction><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>It’s tempting to see this as unnecessary overhead—why not just write the code you need, and refactor later if you really need to swap implementations? But in practice, I’ve found that starting with an abstraction has a few big benefits:</p><ul><li><strong>Clarity of intent:</strong> By defining the interface first, I’m forced to think about what functionality I actually need. I can even start calling the methods from the consumer side before I’ve implemented them, which is a great way to see if the API feels right in practice.</li><li><strong>Faster iteration:</strong> The in-memory implementation is useless in production, but it’s incredibly convenient for local development and testing. I can get the rest of the system working, run both manual and automated tests, and only worry about the “real” implementation when I’m ready.</li><li><strong>Parallel development:</strong> If the task is split between multiple developers, I can hand off the SQL implementation to someone else, without breaking the contract between the backend and frontend, or between the controller/route and the repository. Everyone can work in parallel, with confidence that things will fit together.</li><li><strong>Easy swapping:</strong> When the time comes to switch from the in-memory version to the real thing, it’s just a matter of wiring up the new implementation. No need to touch the rest of the codebase.</li><li><strong>Bonus point:</strong> It’s actually more common than you’d think that YAGNI (You Ain’t Gonna Need It) comes into play where you don’t expect it. Like starting out with a file-based storage and finding it’s actually sufficient for your needs for years and years before you actually need that enterprise cluster-solar-elastic-cosmic db thing Azure has been trying to sell you.</li></ul><h2 id=when-you-dont-need-an-abstraction>When You <em>Don’t</em> Need an Abstraction
<a class=heading-link href=#when-you-dont-need-an-abstraction><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Of course, not every bit of code needs an interface or extra layer. Sometimes, a direct implementation is the right call. For example:</p><ul><li>One-off scripts or migrations</li><li>Truly trivial logic that’s unlikely to change</li><li>Internal code with only one consumer</li><li>Quick prototypes or spikes</li><li>When speed of delivery is more important than flexibility</li></ul><p>This isn’t an exhaustive list, but the point is: be intentional. Reach for abstractions when they solve a real problem, not just out of habit.</p><p>Be <em>very</em> careful with those last two, though; you never know when your prototype is thrown into production and you (or some other sorry soul) will have to maintain it.</p><h2 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In my experience, the small up-front cost of defining an abstraction often pays for itself many times over. It’s not just about future-proofing or testability (though those are nice side effects)—it’s about making it easier to think, to iterate, and to collaborate. Even if you’re the only developer on the project, your future self will thank you.</p><p>And if you’re coming from Elm, where the architecture is almost invisible, it’s worth remembering that a little bit of explicit structure can go a long way—especially in languages where the compiler isn’t holding your hand quite as tightly.</p></div><footer></footer></article></section></div><style>form{display:flex;justify-content:center}</style><form action="https://api.follow.it/subscription-form/SDRVMUk2VmsySENBNk94RDNKNDFnS3NmWlQ5a3gxejNIeUlJWHl3QjdqNnRHdENkaXp5aXZhZlFvcGtzcEZ3K0o5TFVRdSt2WWM5RWRsWmZwWVhNUS9PZjJqMWZ3aHBwZUhjT1ZpWXBGRkdZOWtIcGhYQkJkSkE4QTQ1eHl5YkF8RTZHTExQOWFrN1pFY1F0RzZ5c3pVN2I1QTI1YXNtMjZiYllLU25zQkJ3bz0=/8" method=post><input type=email name=email required placeholder=Email spellcheck=false style="padding:1rem;border:none;border-radius:1rem 0 0 1rem;outline:none">
<button type=submit style="border:none;border-radius:0 1rem 1rem 0;outline:none;background:rgba(127,127,127,5%);cursor:pointer">
Subscribe</button></form><div id=elm-widget></div><script src=/widget.js></script><script>Elm.Main.init({node:document.getElementById("elm-widget"),flags:window.location.pathname})</script><script type=text/javascript src="https://platform-api.sharethis.com/js/sharethis.js#property=6834b86198608700128c9ffa&product=sticky-share-buttons" async></script><footer class=footer><section class=container>© 2021 - 2025 Christian Ekrem
<script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-emoji=🍺 data-id=cekrem data-description="Support me on Buy me a coffee!" data-message data-color=#ddd data-position=Left data-x_margin=18 data-y_margin=18></script></section><script src=https://formspree.io/js/formbutton-v1.min.js defer></script></footer><script src=https://sdk.feedback.one/v0/core.min.js data-project-id=019589e0-c6fb-7b80-b6ae-dffbfbb11f72 defer></script></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script data-goatcounter=https://cekrem.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>