<!doctype html><html lang=en><head><title>React.memo Demystified: When It Helps and When It Hurts · cekrem.github.io</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Christian Ekrem"><meta name=description content="A deep dive into React's memoization tools and the hidden pitfalls that make them harder to use than you think"><meta name=keywords content="developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cekrem.github.io/images/featured-with-margins.png"><meta name=twitter:title content="React.memo Demystified: When It Helps and When It Hurts"><meta name=twitter:description content="A deep dive into React's memoization tools and the hidden pitfalls that make them harder to use than you think"><meta property="og:url" content="https://cekrem.github.io/posts/react-memo-when-it-helps-when-it-hurts/"><meta property="og:site_name" content="cekrem.github.io"><meta property="og:title" content="React.memo Demystified: When It Helps and When It Hurts"><meta property="og:description" content="A deep dive into React's memoization tools and the hidden pitfalls that make them harder to use than you think"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-02T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-02T00:00:00+00:00"><meta property="article:tag" content="React"><meta property="article:tag" content="Performance"><meta property="article:tag" content="Architecture"><meta property="article:tag" content="Clean Architecture"><meta property="article:tag" content="Typescript"><meta property="og:image" content="https://cekrem.github.io/images/featured-with-margins.png"><link rel=canonical href=https://cekrem.github.io/posts/react-memo-when-it-helps-when-it-hurts/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.657562d88d5611df09220fe951c36c8ea0364be9e779347674af6bdb539505a9.css integrity="sha256-ZXVi2I1WEd8JIg/pUcNsjqA2S+nneTR2dK9r21OVBak=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-light"><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://cekrem.github.io/>cekrem.github.io
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/hire/>Hire me?</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/books-i-think-software-engineers-should-read>Recommended Books</a></li><li class=navigation-item><a class=navigation-link href=https://creators.spotify.com/pod/show/disippel>Podcast (🇳🇴)</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://cekrem.github.io/posts/react-memo-when-it-helps-when-it-hurts/>React.memo Demystified: When It Helps and When It Hurts</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-04-02T00:00:00Z>April 2, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
7-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/react/>React</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/performance/>Performance</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/architecture/>Architecture</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/clean-architecture/>Clean Architecture</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/typescript/>Typescript</a></span></div></div></header><div class=post-content><h2 id=the-promise-of-memoization>The Promise of Memoization
<a class=heading-link href=#the-promise-of-memoization><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>When React applications start to slow down, <code>React.memo</code>, <code>useMemo</code>, and <code>useCallback</code> are often the first tools developers reach for. After all, preventing unnecessary re-renders seems like a straightforward path to better performance. But in the React ecosystem, memoization is far more complex than it first appears.</p><p>In this post, we&rsquo;ll look at how these tools actually work under the hood, the subtle ways they can fail, and when they&rsquo;re truly beneficial versus when they&rsquo;re just adding unnecessary complexity.</p><p>If you haven&rsquo;t already, be sure to check out <a href=/posts/beyond-react-memo-smarter-performance-optimization/>my previous posts about optimization <em>without</em> using memoization</a>.</p><h2 id=understanding-the-problem-javascript-reference-comparisons>Understanding the Problem: JavaScript Reference Comparisons
<a class=heading-link href=#understanding-the-problem-javascript-reference-comparisons><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>At its core, the need for memoization in React stems from how JavaScript compares objects, arrays, and functions. While primitive values (strings, numbers, booleans) are compared by their actual value, objects are compared by reference:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-style:italic>// Primitives compare by value
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>const</span> a = 1;
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> b = 1;
</span></span><span style=display:flex><span>a === b; <span style=font-style:italic>// true
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>
</span></span><span style=display:flex><span><span style=font-style:italic>// Objects compare by reference
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>const</span> objA = { id: <span>1</span> };
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> objB = { id: <span>1</span> };
</span></span><span style=display:flex><span>objA === objB; <span style=font-style:italic>// false, different references
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>
</span></span><span style=display:flex><span><span style=font-style:italic>// To make comparison true, they need to reference the same object
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>const</span> objC = objA;
</span></span><span style=display:flex><span>objA === objC; <span style=font-style:italic>// true
</span></span></span></code></pre></div><p>This becomes a problem in React because:</p><ol><li>Components re-render when their state changes or when their parent component re-renders</li><li>When a component re-renders, all its local variables (including objects and functions) are recreated <em>with new references</em></li><li>If these new references are passed as props or used in hook dependencies, they&rsquo;ll trigger unnecessary re-renders or effect executions</li></ol><h2 id=usememo-and-usecallback-under-the-hood>useMemo and useCallback Under the Hood
<a class=heading-link href=#usememo-and-usecallback-under-the-hood><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>To solve this problem, React provides memoization hooks that preserve references between renders. But how do they actually work?</p><p>Both <code>useMemo</code> and <code>useCallback</code> primarily exist to help maintain stable references across re-renders. They cache a value and only recalculate it when specified dependencies change.</p><p>Here&rsquo;s what they do behind the scenes:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-style:italic>// Conceptual implementation of useCallback
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>let</span> cachedCallback;
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> useCallback = (callback, dependencies) =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>if</span> (dependenciesHaventChanged(dependencies)) {
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> cachedCallback;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  cachedCallback = callback;
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> callback;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic>// Conceptual implementation of useMemo
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>let</span> cachedResult;
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> useMemo = (factory, dependencies) =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>if</span> (dependenciesHaventChanged(dependencies)) {
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> cachedResult;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  cachedResult = factory();
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> cachedResult;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The main difference: <code>useCallback</code> caches the function itself, while <code>useMemo</code> caches the return value of the function it receives.</p><h2 id=the-most-common-misconception-memoizing-props>The Most Common Misconception: Memoizing Props
<a class=heading-link href=#the-most-common-misconception-memoizing-props><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>One of the most widespread misconceptions is that memoizing props with <code>useCallback</code> or <code>useMemo</code> prevents child components from re-rendering:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> Component = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-style:italic>// People think this prevents re-renders in child components
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  <span style=font-weight:700>const</span> onClick = useCallback(() =&gt; {
</span></span><span style=display:flex><span>    console.log(<span style=font-style:italic>&#34;clicked&#34;</span>);
</span></span><span style=display:flex><span>  }, []);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> &lt;<span style=font-weight:700>button</span> onClick={onClick}&gt;Click me&lt;/<span style=font-weight:700>button</span>&gt;;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>This is simply not true. If a parent component re-renders, all of its children will re-render by default, regardless of whether their props changed or not. Memoizing props only helps in two specific scenarios:</p><ol><li>When the prop is used as a dependency in a hook in the child component</li><li>When the child component is wrapped in <code>React.memo</code></li></ol><h2 id=what-reactmemo-actually-does>What React.memo Actually Does
<a class=heading-link href=#what-reactmemo-actually-does><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><code>React.memo</code> is a higher-order component that memoizes the result of a component render. It performs a shallow comparison of props to determine if a re-render is necessary:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> ChildComponent = ({ data, onClick }) =&gt; {
</span></span><span style=display:flex><span>  <span style=font-style:italic>// Component implementation
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> MemoizedChild = React.memo(ChildComponent);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> ParentComponent = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-style:italic>// Without memoization, these get new references on every render
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  <span style=font-weight:700>const</span> data = { value: <span>42</span> };
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> onClick = () =&gt; console.log(<span style=font-style:italic>&#34;clicked&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-style:italic>// MemoizedChild will re-render on every ParentComponent render
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  <span style=font-style:italic>// despite React.memo, because props keep changing
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  <span style=font-weight:700>return</span> &lt;<span style=font-weight:700>MemoizedChild</span> data={data} onClick={onClick} /&gt;;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>In this example, <code>React.memo</code> doesn&rsquo;t prevent re-renders because the props keep changing references. This is where <code>useMemo</code> and <code>useCallback</code> become useful:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> ParentComponent = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-style:italic>// Stable references across renders
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  <span style=font-weight:700>const</span> data = useMemo(() =&gt; ({ value: <span>42</span> }), []);
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> onClick = useCallback(() =&gt; console.log(<span style=font-style:italic>&#34;clicked&#34;</span>), []);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-style:italic>// Now MemoizedChild will only re-render when its props actually change
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  <span style=font-weight:700>return</span> &lt;<span style=font-weight:700>MemoizedChild</span> data={data} onClick={onClick} /&gt;;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=the-hidden-pitfalls-of-reactmemo>The Hidden Pitfalls of React.memo
<a class=heading-link href=#the-hidden-pitfalls-of-reactmemo><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Using <code>React.memo</code> effectively is surprisingly difficult. Let&rsquo;s explore some common pitfalls that can silently break your memoization:</p><h3 id=1-the-props-spreading-problem>1. The Props Spreading Problem
<a class=heading-link href=#1-the-props-spreading-problem><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> Child = React.memo(({ data }) =&gt; {
</span></span><span style=display:flex><span>  <span style=font-style:italic>// Component implementation
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic>// This breaks memoization because props might change
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>const</span> Parent = (props) =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> &lt;<span style=font-weight:700>Child</span> {...props} /&gt;;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>When you spread props like this, you have no control over whether the properties that <code>Child</code> receives maintain stable references. Someone using your <code>Parent</code> component could unwittingly break the memoization.</p><h3 id=2-the-children-prop-problem>2. The Children Prop Problem
<a class=heading-link href=#2-the-children-prop-problem><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Perhaps the most surprising pitfall is that JSX children are just another prop, and they need to be memoized too:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> MemoComponent = React.memo(({ children }) =&gt; {
</span></span><span style=display:flex><span>  <span style=font-style:italic>// Implementation
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> Parent = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-style:italic>// This breaks memoization! Children is recreated each render
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>MemoComponent</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>div</span>&gt;Some content&lt;/<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=font-weight:700>MemoComponent</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>To fix this, you need to memoize the children:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> Parent = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> content = useMemo(() =&gt; &lt;<span style=font-weight:700>div</span>&gt;Some content&lt;/<span style=font-weight:700>div</span>&gt;, []);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> &lt;<span style=font-weight:700>MemoComponent</span>&gt;{content}&lt;/<span style=font-weight:700>MemoComponent</span>&gt;;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=3-the-nested-memo-component-problem>3. The Nested Memo Component Problem
<a class=heading-link href=#3-the-nested-memo-component-problem><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> InnerChild = React.memo(() =&gt; &lt;<span style=font-weight:700>div</span>&gt;Inner&lt;/<span style=font-weight:700>div</span>&gt;);
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> OuterChild = React.memo(({ children }) =&gt; &lt;<span style=font-weight:700>div</span>&gt;{children}&lt;/<span style=font-weight:700>div</span>&gt;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> Parent = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-style:italic>// Memoization of OuterChild is broken!
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>OuterChild</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>InnerChild</span> /&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=font-weight:700>OuterChild</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Even though both components are memoized, <code>OuterChild</code> will still re-render because the <code>InnerChild</code> JSX element creates a new object reference on each render. The solution? Memoize the child element:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> Parent = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> innerChild = useMemo(() =&gt; &lt;<span style=font-weight:700>InnerChild</span> /&gt;, []);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> &lt;<span style=font-weight:700>OuterChild</span>&gt;{innerChild}&lt;/<span style=font-weight:700>OuterChild</span>&gt;;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=when-should-you-actually-use-memoization>When Should You Actually Use Memoization?
<a class=heading-link href=#when-should-you-actually-use-memoization><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Given all these complexities, when should you actually use React&rsquo;s memoization tools?</p><h3 id=use-reactmemo-when>Use React.memo when:
<a class=heading-link href=#use-reactmemo-when><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ol><li>You have a pure functional component that renders the same result given the same props</li><li>It renders often with the same props</li><li>It&rsquo;s computationally expensive to render</li><li>You&rsquo;ve verified through profiling that it&rsquo;s a performance bottleneck</li></ol><h3 id=use-usememo-when>Use useMemo when:
<a class=heading-link href=#use-usememo-when><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ol><li>You have an expensive calculation that doesn&rsquo;t need to be recalculated on every render</li><li>You need to maintain a stable reference to an object or array that&rsquo;s passed to a memoized component</li><li>You&rsquo;ve measured and confirmed the calculation is actually expensive</li></ol><h3 id=use-usecallback-when>Use useCallback when:
<a class=heading-link href=#use-usecallback-when><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ol><li>You&rsquo;re passing callbacks to optimized child components that rely on reference equality</li><li>The callback is a dependency in a useEffect hook</li><li>You need to maintain a stable function reference for event handlers in memoized components</li></ol><h2 id=the-composition-alternative>The Composition Alternative
<a class=heading-link href=#the-composition-alternative><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Before reaching for memoization, consider if your component structure could be improved through composition. Component composition often addresses performance issues more elegantly than memoization.</p><p>For example, instead of memoizing an expensive component:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> ParentWithState = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [count, setCount] = useState(0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>button</span> onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/<span style=font-weight:700>button</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>ExpensiveComponent</span> /&gt; {<span style=font-style:italic>/* Re-renders on every count change */</span>}
</span></span><span style=display:flex><span>    &lt;/<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Move the state to a more specific container:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> CounterButton = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [count, setCount] = useState(0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> &lt;<span style=font-weight:700>button</span> onClick={() =&gt; setCount(count + 1)}&gt;Count: {count}&lt;/<span style=font-weight:700>button</span>&gt;;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> Parent = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>CounterButton</span> /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>ExpensiveComponent</span> /&gt; {<span style=font-style:italic>/* No longer re-renders when count changes */</span>}
</span></span><span style=display:flex><span>    &lt;/<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Memoization in React is a powerful optimization technique, but it&rsquo;s also fraught with subtleties that can trip up even experienced developers. Before liberally applying <code>React.memo</code>, <code>useMemo</code>, and <code>useCallback</code> throughout your codebase:</p><ol><li><strong>Profile first</strong>: Use React DevTools Profiler to identify actual performance bottlenecks</li><li><strong>Consider composition</strong>: Restructuring components can eliminate the need for memoization</li><li><strong>Mind the pitfalls</strong>: Be aware of the many ways memoization can silently break</li><li><strong>Measure again</strong>: Verify that your optimizations actually improve performance</li></ol><p>When used judiciously and correctly, memoization can significantly improve React application performance. But when applied without care, it can increase complexity with little benefit or even negative performance impact.</p><p>Remember that premature optimization is the root of much evil in software development. Start with clean component composition following functional programming principles, measure performance, and only then reach for memoization when you have concrete evidence it&rsquo;s needed.</p><p>What are your experiences with React&rsquo;s memoization tools? Have you found other patterns that help avoid unnecessary re-renders? I&rsquo;d love to hear about it (use the feedback widget on the right).</p></div><footer></footer></article></section></div><script type=text/javascript src=https://testimonial.to/js/iframeResizer.min.js></script><style>form{display:flex;justify-content:center}</style><form action="https://api.follow.it/subscription-form/SDRVMUk2VmsySENBNk94RDNKNDFnS3NmWlQ5a3gxejNIeUlJWHl3QjdqNnRHdENkaXp5aXZhZlFvcGtzcEZ3K0o5TFVRdSt2WWM5RWRsWmZwWVhNUS9PZjJqMWZ3aHBwZUhjT1ZpWXBGRkdZOWtIcGhYQkJkSkE4QTQ1eHl5YkF8RTZHTExQOWFrN1pFY1F0RzZ5c3pVN2I1QTI1YXNtMjZiYllLU25zQkJ3bz0=/8" method=post><input type=email name=email required placeholder=Email spellcheck=false style=padding:1rem;border:none;outline:none>
<button type=submit style=border:none;outline:none;background:#eee;cursor:pointer>
Subscribe</button></form><div id=testemonials class=container style="background:#fff !important;clip-path:inset(0 0 90px 0);padding:24px;border-radius:24px;opacity:0;max-height:0;transition:opacity 1s,max-height 1s"><iframe id=testimonialto-carousel-christian-ekrem-tag-all-light src="https://embed-v2.testimonial.to/carousel/all/christian-ekrem?theme=light&autoplay=off&showmore=on&one-row=on&hideDate=off&same-height=off&tag=all&arrowColor=9BA9B4" frameborder=0 scrolling=no width=100%></iframe></div><script type=text/javascript>location.pathname in{"":!0,"/":!0,"/hire/":!0,"/hire":!0}&&setTimeout(()=>{iFrameResize({log:!1,checkOrigin:!1},"#testimonialto-carousel-christian-ekrem-tag-all-light");const e=document.getElementById("testemonials");e.style.display="block",e.style.opacity=1,e.style.maxHeight="600px"},1e3)</script><footer class=footer><section class=container>© 2021 - 2025 Christian Ekrem
<script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-emoji=🍺 data-id=cekrem data-description="Support me on Buy me a coffee!" data-message data-color=#ddd data-position=Right data-x_margin=18 data-y_margin=18></script></section><script src=https://formspree.io/js/formbutton-v1.min.js defer></script></footer><script src=https://sdk.feedback.one/v0/core.min.js data-project-id=019589e0-c6fb-7b80-b6ae-dffbfbb11f72 defer></script></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script data-goatcounter=https://cekrem.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>