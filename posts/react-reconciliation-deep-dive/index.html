<!doctype html><html lang=en><head><title>React Reconciliation: The Hidden Engine Behind Your Components · cekrem.github.io</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Christian Ekrem"><meta name=description content="A deep dive into how React's reconciliation algorithm works and why it matters for performance"><meta name=keywords content="developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cekrem.github.io/images/featured-with-margins.png"><meta name=twitter:title content="React Reconciliation: The Hidden Engine Behind Your Components"><meta name=twitter:description content="A deep dive into how React's reconciliation algorithm works and why it matters for performance"><meta property="og:url" content="https://cekrem.github.io/posts/react-reconciliation-deep-dive/"><meta property="og:site_name" content="cekrem.github.io"><meta property="og:title" content="React Reconciliation: The Hidden Engine Behind Your Components"><meta property="og:description" content="A deep dive into how React's reconciliation algorithm works and why it matters for performance"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-08T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-08T00:00:00+00:00"><meta property="article:tag" content="React"><meta property="article:tag" content="Performance"><meta property="article:tag" content="Architecture"><meta property="article:tag" content="Clean Architecture"><meta property="article:tag" content="Typescript"><meta property="og:image" content="https://cekrem.github.io/images/featured-with-margins.png"><link rel=canonical href=https://cekrem.github.io/posts/react-reconciliation-deep-dive/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.0be07cbe43dba3fa453dd30d5e061a4931b10e5b391f3ea77262bb86ffc94b4d.css integrity="sha256-C+B8vkPbo/pFPdMNXgYaSTGxDls5Hz6ncmK7hv/JS00=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.be284be20943b01514c49cbe3832fe8cc215513c0e5962b1d349102cf16f2c25.css integrity="sha256-vihL4glDsBUUxJy+ODL+jMIVUTwOWWKx00kQLPFvLCU=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://cekrem.github.io/>cekrem.github.io
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/hire/>Hire me?</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/books-i-think-software-engineers-should-read>Recommended Books</a></li><li class=navigation-item><a class=navigation-link href=https://creators.spotify.com/pod/show/disippel>Podcast (🇳🇴)</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://cekrem.github.io/posts/react-reconciliation-deep-dive/>React Reconciliation: The Hidden Engine Behind Your Components</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-04-08T00:00:00Z>April 8, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
12-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/react/>React</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/performance/>Performance</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/architecture/>Architecture</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/clean-architecture/>Clean Architecture</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/typescript/>Typescript</a></span></div></div></header><div class=post-content><h5 id=update-while-simplifying-a-complex-code-example-shortly-before-publishing-i-messed-up-some-details-thanks-to-reader-feedback-for-pointing-this-out-im-very-grateful-i-also-messed-up-an-internal-link-but-thats-fixed-as-well-thanks-again>Update: While simplifying a complex code example shortly before publishing, I messed up some details. Thanks to reader feedback for pointing this out, I&rsquo;m very grateful! I also messed up an internal link, but that&rsquo;s fixed as well. Thanks again
<a class=heading-link href=#update-while-simplifying-a-complex-code-example-shortly-before-publishing-i-messed-up-some-details-thanks-to-reader-feedback-for-pointing-this-out-im-very-grateful-i-also-messed-up-an-internal-link-but-thats-fixed-as-well-thanks-again><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h5><h2 id=the-reconciliation-engine>The Reconciliation Engine
<a class=heading-link href=#the-reconciliation-engine><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In my previous articles (<a href=/posts/beyond-react-memo-smarter-performance-optimization/>1</a>, <a href=/posts/react-memo-when-it-helps-when-it-hurts/>2</a>), I explored how <code>React.memo</code> works and smarter ways to optimize performance through composition. But to truly master React performance, we need to understand the engine that powers it all: React&rsquo;s reconciliation algorithm.</p><p>Reconciliation is the process by which React updates the DOM to match your component tree. It&rsquo;s what makes React&rsquo;s declarative programming model possible - you describe what you want, and React figures out how to make it happen efficiently.</p><h2 id=component-identity-and-state-persistence>Component Identity and State Persistence
<a class=heading-link href=#component-identity-and-state-persistence><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Before diving into the technical details, let&rsquo;s explore a surprising behavior that reveals how React thinks about component identity.</p><p>Consider this simple text input toggle example:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#ff6ac1>const</span> UserInfoForm <span style=color:#ff6ac1>=</span> () <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> [isEditing, setIsEditing] <span style=color:#ff6ac1>=</span> useState(<span style=color:#ff6ac1>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#ff6ac1>div</span> <span style=color:#57c7ff>className</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;form-container&#34;</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>button</span> <span style=color:#57c7ff>onClick</span><span style=color:#ff6ac1>=</span>{() <span style=color:#ff6ac1>=&gt;</span> setIsEditing(<span style=color:#ff6ac1>!</span>isEditing)}&gt;
</span></span><span style=display:flex><span>        {isEditing <span style=color:#ff6ac1>?</span> <span style=color:#5af78e>&#34;Cancel&#34;</span> <span style=color:#ff6ac1>:</span> <span style=color:#5af78e>&#34;Edit&#34;</span>}
</span></span><span style=display:flex><span>      &lt;/<span style=color:#ff6ac1>button</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      {isEditing <span style=color:#ff6ac1>?</span> (
</span></span><span style=display:flex><span>        &lt;<span style=color:#ff6ac1>input</span>
</span></span><span style=display:flex><span>          <span style=color:#57c7ff>type</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;text&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#57c7ff>placeholder</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;Enter your name&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#57c7ff>className</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;edit-input&#34;</span>
</span></span><span style=display:flex><span>        /&gt;
</span></span><span style=display:flex><span>      ) <span style=color:#ff6ac1>:</span> (
</span></span><span style=display:flex><span>        &lt;<span style=color:#ff6ac1>input</span>
</span></span><span style=display:flex><span>          <span style=color:#57c7ff>type</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;text&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#57c7ff>placeholder</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;Enter your name&#34;</span>
</span></span><span style=display:flex><span>          <span style=color:#57c7ff>disabled</span>
</span></span><span style=display:flex><span>          <span style=color:#57c7ff>className</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;view-input&#34;</span>
</span></span><span style=display:flex><span>        /&gt;
</span></span><span style=display:flex><span>      )}
</span></span><span style=display:flex><span>    &lt;/<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The interesting behavior occurs when you interact with this form. If you type something into the input field while editing and then click the &ldquo;Cancel&rdquo; button, your text remains when you click &ldquo;Edit&rdquo; again! This happens even though the two <code>input</code> elements have different props (one is disabled with a different class).</p><p>React preserves the DOM element and its state because both elements are of the same type (<code>input</code>) at the same position in the element tree. React simply updates the props of the existing element rather than recreating it.</p><p>But if we changed our implementation to:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>{
</span></span><span style=display:flex><span>  isEditing <span style=color:#ff6ac1>?</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#ff6ac1>input</span> <span style=color:#57c7ff>type</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;text&#34;</span> <span style=color:#57c7ff>placeholder</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;Enter your name&#34;</span> <span style=color:#57c7ff>className</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;edit-input&#34;</span> /&gt;
</span></span><span style=display:flex><span>  ) <span style=color:#ff6ac1>:</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#ff6ac1>div</span> <span style=color:#57c7ff>className</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;view-only-display&#34;</span>&gt;Name will appear here&lt;/<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then toggling the edit mode would result in completely different elements being mounted and unmounted, with any user input being lost.</p><p>This behavior highlights a fundamental aspect of React&rsquo;s reconciliation: <strong>element type is the primary factor in determining identity</strong>. Understanding this concept is key to mastering React performance.</p><h2 id=element-trees-not-virtual-dom>Element Trees, Not Virtual DOM
<a class=heading-link href=#element-trees-not-virtual-dom><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>You&rsquo;ve probably heard that React uses a &ldquo;Virtual DOM&rdquo; to optimize updates. While this is a useful mental model, it&rsquo;s more accurate to think of React&rsquo;s internal representation as an element tree - a lightweight description of what should be on screen.</p><p>When you write JSX like this:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#ff6ac1>const</span> Component <span style=color:#ff6ac1>=</span> () <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>h1</span>&gt;Hello&lt;/<span style=color:#ff6ac1>h1</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>p</span>&gt;World&lt;/<span style=color:#ff6ac1>p</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>React transforms it into a tree of plain JavaScript objects:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>type</span><span style=color:#ff6ac1>:</span> <span style=color:#5af78e>&#39;div&#39;</span>,
</span></span><span style=display:flex><span>  props<span style=color:#ff6ac1>:</span> {
</span></span><span style=display:flex><span>    children<span style=color:#ff6ac1>:</span> [
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>type</span><span style=color:#ff6ac1>:</span> <span style=color:#5af78e>&#39;h1&#39;</span>,
</span></span><span style=display:flex><span>        props<span style=color:#ff6ac1>:</span> {
</span></span><span style=display:flex><span>          children<span style=color:#ff6ac1>:</span> <span style=color:#5af78e>&#39;Hello&#39;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>type</span><span style=color:#ff6ac1>:</span> <span style=color:#5af78e>&#39;p&#39;</span>,
</span></span><span style=display:flex><span>        props<span style=color:#ff6ac1>:</span> {
</span></span><span style=display:flex><span>          children<span style=color:#ff6ac1>:</span> <span style=color:#5af78e>&#39;World&#39;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For DOM elements like <code>div</code> or <code>input</code>, the &ldquo;type&rdquo; is a string. For custom React components, the &ldquo;type&rdquo; is the actual function reference:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>type</span><span style=color:#ff6ac1>:</span> Input, <span style=color:#78787e>// Reference to the Input function itself
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>  props<span style=color:#ff6ac1>:</span> {
</span></span><span style=display:flex><span>    id<span style=color:#ff6ac1>:</span> <span style=color:#5af78e>&#34;company-tax-id&#34;</span>,
</span></span><span style=display:flex><span>    placeholder<span style=color:#ff6ac1>:</span> <span style=color:#5af78e>&#34;Enter company Tax ID&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=how-reconciliation-works>How Reconciliation Works
<a class=heading-link href=#how-reconciliation-works><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>When React needs to update the UI (after state changes or a re-render), it:</p><ol><li>Creates a new element tree by calling your components</li><li>Compares it with the previous tree</li><li>Figures out what DOM operations are needed to make the real DOM match the new tree</li><li>Performs those operations efficiently</li></ol><p>The comparison algorithm follows these key principles:</p><h3 id=1-element-type-determines-identity>1. Element Type Determines Identity
<a class=heading-link href=#1-element-type-determines-identity><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>React first checks the &ldquo;type&rdquo; of elements. If the type changes, React rebuilds the entire subtree:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#78787e>// From this (first render)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>&lt;<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#ff6ac1>Counter</span> /&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// To this (second render)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>&lt;<span style=color:#ff6ac1>span</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#ff6ac1>Counter</span> /&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#ff6ac1>span</span>&gt;
</span></span></code></pre></div><p>Since <code>div</code> changed to <code>span</code>, React destroys the entire old tree (including <code>Counter</code>) and builds a new one from scratch.</p><h3 id=2-position-in-the-tree-matters>2. Position in the Tree Matters
<a class=heading-link href=#2-position-in-the-tree-matters><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>React&rsquo;s reconciliation algorithm relies heavily on component position within the tree structure. Position serves as a primary identity indicator during the diffing process.</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#78787e>// Let&#39;s pretend showDetails is true: Render UserProfile
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>&lt;&gt;
</span></span><span style=display:flex><span>  {showDetails <span style=color:#ff6ac1>?</span> &lt;<span style=color:#ff6ac1>UserProfile</span> <span style=color:#57c7ff>userId</span><span style=color:#ff6ac1>=</span>{<span style=color:#ff9f43>123</span>} /&gt; <span style=color:#ff6ac1>:</span> &lt;<span style=color:#ff6ac1>LoginPrompt</span> /&gt;}
</span></span><span style=display:flex><span>&lt;/&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#78787e>// Let&#39;s pretend showDetails is false: Render LoginPrompt instead
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>&lt;&gt;
</span></span><span style=display:flex><span>  {showDetails <span style=color:#ff6ac1>?</span> &lt;<span style=color:#ff6ac1>UserProfile</span> <span style=color:#57c7ff>userId</span><span style=color:#ff6ac1>=</span>{<span style=color:#ff9f43>123</span>} /&gt; <span style=color:#ff6ac1>:</span> &lt;<span style=color:#ff6ac1>LoginPrompt</span> /&gt;}
</span></span><span style=display:flex><span>&lt;/&gt;
</span></span></code></pre></div><p>In this conditional example, React treats the first child position of the fragment as a single &ldquo;slot.&rdquo; When <code>showDetails</code> changes from <code>true</code> to <code>false</code>, React compares what&rsquo;s in that position across renders and sees different component types (<code>UserProfile</code> vs <code>LoginPrompt</code>). Since the component type at position 1 has changed, React unmounts the previous component entirely (including its state) and mounts the new one.</p><p>This position-based identity also explains why components preserve their state in simpler cases:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#78787e>// Before
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>&lt;&gt;
</span></span><span style=display:flex><span>  {isPrimary <span style=color:#ff6ac1>?</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#ff6ac1>UserProfile</span> <span style=color:#57c7ff>userId</span><span style=color:#ff6ac1>=</span>{<span style=color:#ff9f43>123</span>} <span style=color:#57c7ff>role</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;primary&#34;</span> /&gt;
</span></span><span style=display:flex><span>  ) <span style=color:#ff6ac1>:</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#ff6ac1>UserProfile</span> <span style=color:#57c7ff>userId</span><span style=color:#ff6ac1>=</span>{<span style=color:#ff9f43>456</span>} <span style=color:#57c7ff>role</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;secondary&#34;</span> /&gt;
</span></span><span style=display:flex><span>  )}
</span></span><span style=display:flex><span>&lt;/&gt;
</span></span></code></pre></div><p>Here, regardless of the <code>isPrimary</code> value, React sees the same component type (<code>UserProfile</code>) at the same position. It will preserve the component instance, simply updating its props rather than remounting it.</p><p>This position-based approach works well for most scenarios, but becomes problematic when:</p><ol><li>Component positions shift dynamically (like in sorted lists)</li><li>You need to preserve state when components move between different positions</li><li>You want to control exactly when components should be remounted</li></ol><p>This is where React&rsquo;s key system comes in.</p><h3 id=3-keys-override-position-based-comparison>3. Keys Override Position-Based Comparison
<a class=heading-link href=#3-keys-override-position-based-comparison><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>The <code>key</code> attribute gives developers explicit control over component identity, overriding React&rsquo;s default position-based identification:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#ff6ac1>const</span> TabContent <span style=color:#ff6ac1>=</span> ({ activeTab, tabs }) <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#ff6ac1>div</span> <span style=color:#57c7ff>className</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;tab-container&#34;</span>&gt;
</span></span><span style=display:flex><span>      {tabs.map((tab) <span style=color:#ff6ac1>=&gt;</span> (
</span></span><span style=display:flex><span>        <span style=color:#78787e>// Key overrides position-based comparison
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        &lt;<span style=color:#ff6ac1>div</span> <span style=color:#57c7ff>key</span><span style=color:#ff6ac1>=</span>{tab.id} <span style=color:#57c7ff>className</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;tab-content&#34;</span>&gt;
</span></span><span style=display:flex><span>          {activeTab <span style=color:#ff6ac1>===</span> tab.id <span style=color:#ff6ac1>?</span> (
</span></span><span style=display:flex><span>            &lt;<span style=color:#ff6ac1>UserProfile</span>
</span></span><span style=display:flex><span>              <span style=color:#57c7ff>key</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;active-profile&#34;</span>
</span></span><span style=display:flex><span>              <span style=color:#57c7ff>userId</span><span style=color:#ff6ac1>=</span>{tab.userId}
</span></span><span style=display:flex><span>              <span style=color:#57c7ff>role</span><span style=color:#ff6ac1>=</span>{tab.role}
</span></span><span style=display:flex><span>            /&gt;
</span></span><span style=display:flex><span>          ) <span style=color:#ff6ac1>:</span> (
</span></span><span style=display:flex><span>            &lt;<span style=color:#ff6ac1>div</span> <span style=color:#57c7ff>key</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;placeholder&#34;</span> <span style=color:#57c7ff>className</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;placeholder&#34;</span>&gt;
</span></span><span style=display:flex><span>              Select <span style=color:#ff6ac1>this</span> tab to view {tab.userId}<span style=color:#ff5c57>&#39;</span>s profile
</span></span><span style=display:flex><span>            &lt;/<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>          )}
</span></span><span style=display:flex><span>        &lt;/<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>      ))}
</span></span><span style=display:flex><span>    &lt;/<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Even if the <code>UserProfile</code> component appears in different positions across conditional renders, React will treat components with the same key as the same component. When a tab becomes active, React preserves the component&rsquo;s state because the key &ldquo;active-profile&rdquo; remains consistent, allowing for smoother transitions between tabs.</p><p>This illustrates how keys provide a way to maintain component identity regardless of structural position in the render tree - a powerful tool for controlling how React reconciles your component hierarchy.</p><h2 id=the-magic-of-keys>The Magic of Keys
<a class=heading-link href=#the-magic-of-keys><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Keys are primarily known for their role in lists, but they have deeper implications for React&rsquo;s reconciliation process.</p><h3 id=why-keys-are-required-for-lists>Why Keys Are Required for Lists
<a class=heading-link href=#why-keys-are-required-for-lists><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>When rendering lists, React uses keys to track which items have been added, removed, or reordered:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>&lt;<span style=color:#ff6ac1>ul</span>&gt;
</span></span><span style=display:flex><span>  {items.map((item) <span style=color:#ff6ac1>=&gt;</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#ff6ac1>li</span> <span style=color:#57c7ff>key</span><span style=color:#ff6ac1>=</span>{item.id}&gt;{item.text}&lt;/<span style=color:#ff6ac1>li</span>&gt;
</span></span><span style=display:flex><span>  ))}
</span></span><span style=display:flex><span>&lt;/<span style=color:#ff6ac1>ul</span>&gt;
</span></span></code></pre></div><p>Without keys, React would solely rely on the element&rsquo;s position in the array. If you insert a new item at the beginning, React would see every element as having changed position and would rerender the entire list.</p><p>With keys, React can match elements between renders regardless of their position.</p><h3 id=keys-outside-of-arrays>Keys Outside of Arrays?
<a class=heading-link href=#keys-outside-of-arrays><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>React doesn&rsquo;t force you to add keys for static elements:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#78787e>// No keys needed
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>&lt;&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#ff6ac1>Input</span> /&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#ff6ac1>Input</span> /&gt;
</span></span><span style=display:flex><span>&lt;/&gt;
</span></span></code></pre></div><p>This works because React knows these elements are static - their position in the tree is predictable.</p><p>But keys can be powerful even outside of lists. Consider this example:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#ff6ac1>const</span> Component <span style=color:#ff6ac1>=</span> () <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> [isReverse, setIsReverse] <span style=color:#ff6ac1>=</span> useState(<span style=color:#ff6ac1>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>Input</span> <span style=color:#57c7ff>key</span><span style=color:#ff6ac1>=</span>{isReverse <span style=color:#ff6ac1>?</span> <span style=color:#5af78e>&#34;some-key&#34;</span> <span style=color:#ff6ac1>:</span> <span style=color:#ff6ac1>null</span>} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>Input</span> <span style=color:#57c7ff>key</span><span style=color:#ff6ac1>=</span>{<span style=color:#ff6ac1>!</span>isReverse <span style=color:#ff6ac1>?</span> <span style=color:#5af78e>&#34;some-key&#34;</span> <span style=color:#ff6ac1>:</span> <span style=color:#ff6ac1>null</span>} /&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>When <code>isReverse</code> toggles, the key <code>'some-key'</code> moves from one input to the other, causing React to &ldquo;move&rdquo; the component&rsquo;s state between the two positions!</p><h3 id=mixing-dynamic-and-static-elements>Mixing Dynamic and Static Elements
<a class=heading-link href=#mixing-dynamic-and-static-elements><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>A common worry is whether adding items to a dynamic list might shift the identity of static elements after the list:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>&lt;&gt;
</span></span><span style=display:flex><span>  {items.map((item) <span style=color:#ff6ac1>=&gt;</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#ff6ac1>ListItem</span> <span style=color:#57c7ff>key</span><span style=color:#ff6ac1>=</span>{item.id} /&gt;
</span></span><span style=display:flex><span>  ))}
</span></span><span style=display:flex><span>  &lt;<span style=color:#ff6ac1>StaticElement</span> /&gt; {<span style=color:#78787e>/* Will this re-mount if items change? */</span>}
</span></span><span style=display:flex><span>&lt;/&gt;
</span></span></code></pre></div><p>React handles this intelligently. It treats the entire dynamic list as a single unit at the first position, so the <code>StaticElement</code> will always maintain its position and identity, regardless of changes to the list.</p><p>Here&rsquo;s how React actually represents this internally:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>[
</span></span><span style=display:flex><span>  <span style=color:#78787e>// The entire dynamic array becomes a single child
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>  [
</span></span><span style=display:flex><span>    { <span style=color:#ff6ac1>type</span><span style=color:#ff6ac1>:</span> ListItem, key<span style=color:#ff6ac1>:</span> <span style=color:#5af78e>&#34;1&#34;</span> },
</span></span><span style=display:flex><span>    { <span style=color:#ff6ac1>type</span><span style=color:#ff6ac1>:</span> ListItem, key<span style=color:#ff6ac1>:</span> <span style=color:#5af78e>&#34;2&#34;</span> },
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  { <span style=color:#ff6ac1>type</span><span style=color:#ff6ac1>:</span> StaticElement }, <span style=color:#78787e>// Always maintains its second position
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>];
</span></span></code></pre></div><p>Even if you add or remove items from the list, the <code>StaticElement</code> will remain at position 2 in the parent array. This means it won&rsquo;t re-mount when the list changes. This is a clever optimization that ensures static elements don&rsquo;t get unnecessarily re-mounted due to changes in adjacent dynamic lists.</p><h3 id=3-keys-for-strategic-dom-control>3. Keys for Strategic DOM Control
<a class=heading-link href=#3-keys-for-strategic-dom-control><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Keys aren&rsquo;t just for lists - they&rsquo;re a powerful tool for controlling component and DOM element identity in React. For React component state preservation across different views, remember that key and component type work together - components with the same key but different types will still unmount and remount. In these cases, lifting state up is typically the better approach:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#78787e>// State lifting approach for preserving state across different views (keys are no good here...)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>const</span> TabContent <span style=color:#ff6ac1>=</span> ({ activeTab }) <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#78787e>// State that needs to be preserved across tab changes
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>  <span style=color:#ff6ac1>const</span> [sharedState, setSharedState] <span style=color:#ff6ac1>=</span> useState({
</span></span><span style=display:flex><span>    <span style=color:#78787e>/* initial state */</span>
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>      {activeTab <span style=color:#ff6ac1>===</span> <span style=color:#5af78e>&#34;profile&#34;</span> <span style=color:#ff6ac1>&amp;&amp;</span> (
</span></span><span style=display:flex><span>        &lt;<span style=color:#ff6ac1>ProfileTab</span> <span style=color:#57c7ff>state</span><span style=color:#ff6ac1>=</span>{sharedState} <span style=color:#57c7ff>onStateChange</span><span style=color:#ff6ac1>=</span>{setSharedState} /&gt;
</span></span><span style=display:flex><span>      )}
</span></span><span style=display:flex><span>      {activeTab <span style=color:#ff6ac1>===</span> <span style=color:#5af78e>&#34;settings&#34;</span> <span style=color:#ff6ac1>&amp;&amp;</span> (
</span></span><span style=display:flex><span>        &lt;<span style=color:#ff6ac1>SettingsTab</span> <span style=color:#57c7ff>state</span><span style=color:#ff6ac1>=</span>{sharedState} <span style=color:#57c7ff>onStateChange</span><span style=color:#ff6ac1>=</span>{setSharedState} /&gt;
</span></span><span style=display:flex><span>      )}
</span></span><span style=display:flex><span>      {<span style=color:#78787e>/* Other tabs */</span>}
</span></span><span style=display:flex><span>    &lt;/<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Preserving the key woundn&rsquo;t be enough in this case since the type (and reference) is different between tabs.</p><p>But take a look at this example, however, using keys and uncontrolled components:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#ff6ac1>const</span> UserForm <span style=color:#ff6ac1>=</span> ({ userId }) <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#78787e>// No React state here - using uncontrolled inputs
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#ff6ac1>form</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>input</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>key</span><span style=color:#ff6ac1>=</span>{userId}
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>name</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;username&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#78787e>// Uncontrolled input with defaultValue instead of value
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>defaultValue</span><span style=color:#ff6ac1>=</span><span style=color:#5af78e>&#34;&#34;</span>
</span></span><span style=display:flex><span>      /&gt;
</span></span><span style=display:flex><span>      {<span style=color:#78787e>/* Other form inputs */</span>}
</span></span><span style=display:flex><span>    &lt;/<span style=color:#ff6ac1>form</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>By giving the uncontrolled input a key based on userId, we ensure that React creates a completely new DOM element whenever the userId changes. Since the uncontrolled input&rsquo;s state lives in the DOM itself rather than in React state, this effectively resets the input when switching between different users. In this case <code>key</code> is all you need.</p><p>Quite something, huh?</p><h2 id=state-colocation-a-powerful-performance-pattern>State Colocation: A Powerful Performance Pattern
<a class=heading-link href=#state-colocation-a-powerful-performance-pattern><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>State colocation is a pattern that involves keeping state as close as possible to where it&rsquo;s used. This approach minimizes unnecessary re-renders by ensuring that only the components directly affected by state changes are updated.</p><p>Consider this example:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#78787e>// Poor performance - entire app re-renders when filter changes
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>const</span> App <span style=color:#ff6ac1>=</span> () <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> [filterText, setFilterText] <span style=color:#ff6ac1>=</span> useState(<span style=color:#5af78e>&#34;&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> filteredUsers <span style=color:#ff6ac1>=</span> users.filter((user) <span style=color:#ff6ac1>=&gt;</span> user.name.includes(filterText));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>SearchBox</span> <span style=color:#57c7ff>filterText</span><span style=color:#ff6ac1>=</span>{filterText} <span style=color:#57c7ff>onChange</span><span style=color:#ff6ac1>=</span>{setFilterText} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>UserList</span> <span style=color:#57c7ff>users</span><span style=color:#ff6ac1>=</span>{filteredUsers} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>ExpensiveComponent</span> /&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>When <code>filterText</code> changes, the entire <code>App</code> component re-renders, including <code>ExpensiveComponent</code> which isn&rsquo;t affected by the filter.</p><p>By colocating the filter state with just the components that use it:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#ff6ac1>const</span> UserSection <span style=color:#ff6ac1>=</span> () <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> [filterText, setFilterText] <span style=color:#ff6ac1>=</span> useState(<span style=color:#5af78e>&#34;&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> filteredUsers <span style=color:#ff6ac1>=</span> users.filter((user) <span style=color:#ff6ac1>=&gt;</span> user.name.includes(filterText));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>SearchBox</span> <span style=color:#57c7ff>filterText</span><span style=color:#ff6ac1>=</span>{filterText} <span style=color:#57c7ff>onChange</span><span style=color:#ff6ac1>=</span>{setFilterText} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>UserList</span> <span style=color:#57c7ff>users</span><span style=color:#ff6ac1>=</span>{filteredUsers} /&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>const</span> App <span style=color:#ff6ac1>=</span> () <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>UserSection</span> /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>ExpensiveComponent</span> /&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Now when the filter changes, only <code>UserSection</code> re-renders. This pattern not only improves performance but also leads to better component design by ensuring each component only manages the state that truly belongs to it.</p><h2 id=component-design-optimizing-for-change>Component Design: Optimizing for Change
<a class=heading-link href=#component-design-optimizing-for-change><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Performance optimization is often a component design problem. If a component does too many things, it&rsquo;s more likely to re-render unnecessarily.</p><p>Before reaching for <code>React.memo</code>, ask:</p><ol><li><p><strong>Does this component have mixed responsibilities?</strong> Components that handle multiple concerns are likely to re-render more frequently.</p></li><li><p><strong>Is state being lifted too high?</strong> When state is kept higher in the tree than needed, it causes more components to re-render.</p></li></ol><p>Consider this example:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#78787e>// Problematic design - mixed concerns
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff6ac1>const</span> ProductPage <span style=color:#ff6ac1>=</span> ({ productId }) <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> [selectedSize, setSelectedSize] <span style=color:#ff6ac1>=</span> useState(<span style=color:#5af78e>&#34;medium&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> [quantity, setQuantity] <span style=color:#ff6ac1>=</span> useState(<span style=color:#ff9f43>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> [shipping, setShipping] <span style=color:#ff6ac1>=</span> useState(<span style=color:#5af78e>&#34;express&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> [reviews, setReviews] <span style=color:#ff6ac1>=</span> useState([]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#78787e>// Fetches both product details and reviews
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>  useEffect(() <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>    fetchProductDetails(productId);
</span></span><span style=display:flex><span>    fetchReviews(productId).then(setReviews);
</span></span><span style=display:flex><span>  }, [productId]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>ProductInfo</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>selectedSize</span><span style=color:#ff6ac1>=</span>{selectedSize}
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>onSizeChange</span><span style=color:#ff6ac1>=</span>{setSelectedSize}
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>quantity</span><span style=color:#ff6ac1>=</span>{quantity}
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>onQuantityChange</span><span style=color:#ff6ac1>=</span>{setQuantity}
</span></span><span style=display:flex><span>      /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>ShippingOptions</span> <span style=color:#57c7ff>shipping</span><span style=color:#ff6ac1>=</span>{shipping} <span style=color:#57c7ff>onShippingChange</span><span style=color:#ff6ac1>=</span>{setShipping} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>Reviews</span> <span style=color:#57c7ff>reviews</span><span style=color:#ff6ac1>=</span>{reviews} /&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Every time the size, quantity, or shipping changes, the entire page re-renders, including the unrelated reviews section.</p><p>A better design separates these concerns:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=color:#ff6ac1>const</span> ProductPage <span style=color:#ff6ac1>=</span> ({ productId }) <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>ProductConfig</span> <span style=color:#57c7ff>productId</span><span style=color:#ff6ac1>=</span>{productId} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>ReviewsSection</span> <span style=color:#57c7ff>productId</span><span style=color:#ff6ac1>=</span>{productId} /&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#ff6ac1>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>const</span> ProductConfig <span style=color:#ff6ac1>=</span> ({ productId }) <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> [selectedSize, setSelectedSize] <span style=color:#ff6ac1>=</span> useState(<span style=color:#5af78e>&#34;medium&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> [quantity, setQuantity] <span style=color:#ff6ac1>=</span> useState(<span style=color:#ff9f43>1</span>);
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> [shipping, setShipping] <span style=color:#ff6ac1>=</span> useState(<span style=color:#5af78e>&#34;express&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#78787e>// Product-specific logic
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>ProductInfo</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>selectedSize</span><span style=color:#ff6ac1>=</span>{selectedSize}
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>onSizeChange</span><span style=color:#ff6ac1>=</span>{setSelectedSize}
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>quantity</span><span style=color:#ff6ac1>=</span>{quantity}
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>onQuantityChange</span><span style=color:#ff6ac1>=</span>{setQuantity}
</span></span><span style=display:flex><span>      /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=color:#ff6ac1>ShippingOptions</span> <span style=color:#57c7ff>shipping</span><span style=color:#ff6ac1>=</span>{shipping} <span style=color:#57c7ff>onShippingChange</span><span style=color:#ff6ac1>=</span>{setShipping} /&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff6ac1>const</span> ReviewsSection <span style=color:#ff6ac1>=</span> ({ productId }) <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>const</span> [reviews, setReviews] <span style=color:#ff6ac1>=</span> useState([]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  useEffect(() <span style=color:#ff6ac1>=&gt;</span> {
</span></span><span style=display:flex><span>    fetchReviews(productId).then(setReviews);
</span></span><span style=display:flex><span>  }, [productId]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#ff6ac1>return</span> &lt;<span style=color:#ff6ac1>Reviews</span> <span style=color:#57c7ff>reviews</span><span style=color:#ff6ac1>=</span>{reviews} /&gt;;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>This structure ensures that changing the product size doesn&rsquo;t cause the reviews to re-render. No memoization needed - just good component boundaries.</p><h2 id=reconciliation-and-clean-architecture>Reconciliation and Clean Architecture
<a class=heading-link href=#reconciliation-and-clean-architecture><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>This understanding of reconciliation aligns perfectly with Clean Architecture principles:</p><ol><li><p><strong>Single Responsibility Principle</strong>: Each component should have one reason to change. When components are focused on a single responsibility, they&rsquo;re less likely to trigger unnecessary re-renders.</p></li><li><p><strong>Dependency Inversion</strong>: Components should depend on abstractions, not concrete implementations. This makes it easier to optimize performance through composition.</p></li><li><p><strong>Interface Segregation</strong>: Components should have minimal, focused interfaces. This reduces the chance of prop changes triggering unnecessary re-renders.</p></li></ol><h2 id=practical-guidelines>Practical Guidelines
<a class=heading-link href=#practical-guidelines><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Based on our deep dive into reconciliation, here are some practical guidelines:</p><ol><li><p><strong>Keep component definitions outside parent components</strong> to prevent remounting.</p></li><li><p><strong>Move state down</strong> to isolate re-render boundaries.</p></li><li><p><strong>Be consistent with component types</strong> in the same position to avoid unmounting.</p></li><li><p><strong>Use keys strategically</strong> - not just for lists, but whenever you want to control component identity.</p></li><li><p><strong>When debugging re-render issues</strong>, think in terms of element trees and component identity.</p></li><li><p><strong>Remember that React.memo is just a tool</strong> that works within the constraints of reconciliation - it doesn&rsquo;t change the fundamental algorithm.</p></li></ol><h2 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Understanding React&rsquo;s reconciliation algorithm reveals the &ldquo;why&rdquo; behind many React performance patterns. It explains why composition works so well, why we need keys for lists, and why defining components inside other components is problematic.</p><p>This knowledge helps us make better architectural decisions that naturally lead to performant React applications. Rather than fighting React&rsquo;s reconciliation algorithm with excessive memoization, we can work with it by designing component structures that align with how React identifies and updates components.</p><p>The next time you&rsquo;re optimizing a React application, think about how your component structure affects the reconciliation process. Sometimes, the best optimization is a simpler, more focused component tree that respects how React identifies and updates components.</p><p>What patterns have you found most effective for working with React&rsquo;s reconciliation process? I&rsquo;d love to hear your experiences, use the Feedback.One button on the right 🤓</p></div><footer></footer></article></section></div><style>form{display:flex;justify-content:center}</style><form action="https://api.follow.it/subscription-form/SDRVMUk2VmsySENBNk94RDNKNDFnS3NmWlQ5a3gxejNIeUlJWHl3QjdqNnRHdENkaXp5aXZhZlFvcGtzcEZ3K0o5TFVRdSt2WWM5RWRsWmZwWVhNUS9PZjJqMWZ3aHBwZUhjT1ZpWXBGRkdZOWtIcGhYQkJkSkE4QTQ1eHl5YkF8RTZHTExQOWFrN1pFY1F0RzZ5c3pVN2I1QTI1YXNtMjZiYllLU25zQkJ3bz0=/8" method=post><input type=email name=email required placeholder=Email spellcheck=false style="padding:1rem;border:none;border-radius:1rem 0 0 1rem;outline:none">
<button type=submit style="border:none;border-radius:0 1rem 1rem 0;outline:none;background:rgba(127,127,127,5%);cursor:pointer">
Subscribe</button></form><div id=elm-widget></div><script src=/widget.js></script><script>Elm.Main.init({node:document.getElementById("elm-widget"),flags:window.location.pathname})</script><script type=text/javascript src="https://platform-api.sharethis.com/js/sharethis.js#property=6834b86198608700128c9ffa&product=sticky-share-buttons" async></script><footer class=footer><section class=container>© 2021 - 2025 Christian Ekrem
<script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-emoji=🍺 data-id=cekrem data-description="Support me on Buy me a coffee!" data-message data-color=#ddd data-position=Left data-x_margin=18 data-y_margin=18></script></section><script src=https://formspree.io/js/formbutton-v1.min.js defer></script></footer><script src=https://sdk.feedback.one/v0/core.min.js data-project-id=019589e0-c6fb-7b80-b6ae-dffbfbb11f72 defer></script></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script data-goatcounter=https://cekrem.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>