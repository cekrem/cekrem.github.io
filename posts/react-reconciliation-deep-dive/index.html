<!doctype html><html lang=en><head><title>React Reconciliation: The Hidden Engine Behind Your Components Â· cekrem.github.io
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Christian Ekrem"><meta name=description content="A deep dive into how React's reconciliation algorithm works and why it matters for performance"><meta name=keywords content="developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cekrem.github.io/images/featured-with-margins.png"><meta name=twitter:title content="React Reconciliation: The Hidden Engine Behind Your Components"><meta name=twitter:description content="A deep dive into how React's reconciliation algorithm works and why it matters for performance"><meta property="og:url" content="https://cekrem.github.io/posts/react-reconciliation-deep-dive/"><meta property="og:site_name" content="cekrem.github.io"><meta property="og:title" content="React Reconciliation: The Hidden Engine Behind Your Components"><meta property="og:description" content="A deep dive into how React's reconciliation algorithm works and why it matters for performance"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-08T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-08T00:00:00+00:00"><meta property="article:tag" content="React"><meta property="article:tag" content="Performance"><meta property="article:tag" content="Architecture"><meta property="article:tag" content="Clean Architecture"><meta property="article:tag" content="Typescript"><meta property="og:image" content="https://cekrem.github.io/images/featured-with-margins.png"><link rel=canonical href=https://cekrem.github.io/posts/react-reconciliation-deep-dive/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.07092c1350ffd254998dc43a44ae96e617d14af4df4602626878df89189c5e1a.css integrity="sha256-BwksE1D/0lSZjcQ6RK6W5hfRSvTfRgJiaHjfiRicXho=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-light"><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://cekrem.github.io/>cekrem.github.io
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/hire/>Hire me?</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/books-i-think-software-engineers-should-read>Recommended Books</a></li><li class=navigation-item><a class=navigation-link href=https://creators.spotify.com/pod/show/disippel>Podcast (ðŸ‡³ðŸ‡´)</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://cekrem.github.io/posts/react-reconciliation-deep-dive/>React Reconciliation: The Hidden Engine Behind Your Components</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-04-08T00:00:00Z>April 8, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
12-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/react/>React</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/performance/>Performance</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/architecture/>Architecture</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/clean-architecture/>Clean Architecture</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/typescript/>Typescript</a></span></div></div></header><div class=post-content><h5 id=update-the-using-keys-for-advanced-state-preservation-section-has-been-corrected-the-original-example-incorrectly-suggested-that-using-the-same-key-across-different-component-types-would-preserve-state-between-them-this-error-occurred-when-simplifying-a-more-complex-example-shortly-before-publishing-thanks-to-reader-feedback-for-pointing-this-out-im-very-grateful>Update: The &ldquo;Using Keys for Advanced State Preservation&rdquo; section has been corrected. The original example incorrectly suggested that using the same key across different component types would preserve state between them. This error occurred when simplifying a more complex example shortly before publishing. Thanks to reader feedback for pointing this out, I&rsquo;m very grateful!
<a class=heading-link href=#update-the-using-keys-for-advanced-state-preservation-section-has-been-corrected-the-original-example-incorrectly-suggested-that-using-the-same-key-across-different-component-types-would-preserve-state-between-them-this-error-occurred-when-simplifying-a-more-complex-example-shortly-before-publishing-thanks-to-reader-feedback-for-pointing-this-out-im-very-grateful><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h5><h2 id=the-reconciliation-engine>The Reconciliation Engine
<a class=heading-link href=#the-reconciliation-engine><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In my previous articles (<a href=/posts/beyond-react-memo-smarter-performance-optimization/>1</a>, <a href=/posts/react-memo-when-it-helps-when-it-hurts/>2</a>), I explored how <code>React.memo</code> works and smarter ways to optimize performance through composition. But to truly master React performance, we need to understand the engine that powers it all: React&rsquo;s reconciliation algorithm.</p><p>Reconciliation is the process by which React updates the DOM to match your component tree. It&rsquo;s what makes React&rsquo;s declarative programming model possible - you describe what you want, and React figures out how to make it happen efficiently.</p><h2 id=component-identity-and-state-persistence>Component Identity and State Persistence
<a class=heading-link href=#component-identity-and-state-persistence><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Before diving into the technical details, let&rsquo;s explore a surprising behavior that reveals how React thinks about component identity.</p><p>Consider this simple text input toggle example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> UserInfoForm = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [isEditing, setIsEditing] = useState(<span style=font-weight:700>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>div</span> className=<span style=font-style:italic>&#34;form-container&#34;</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>button</span> onClick={() =&gt; setIsEditing(!isEditing)}&gt;
</span></span><span style=display:flex><span>        {isEditing ? <span style=font-style:italic>&#34;Cancel&#34;</span> : <span style=font-style:italic>&#34;Edit&#34;</span>}
</span></span><span style=display:flex><span>      &lt;/<span style=font-weight:700>button</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      {isEditing ? (
</span></span><span style=display:flex><span>        &lt;<span style=font-weight:700>input</span>
</span></span><span style=display:flex><span>          type=<span style=font-style:italic>&#34;text&#34;</span>
</span></span><span style=display:flex><span>          placeholder=<span style=font-style:italic>&#34;Enter your name&#34;</span>
</span></span><span style=display:flex><span>          className=<span style=font-style:italic>&#34;edit-input&#34;</span>
</span></span><span style=display:flex><span>        /&gt;
</span></span><span style=display:flex><span>      ) : (
</span></span><span style=display:flex><span>        &lt;<span style=font-weight:700>input</span>
</span></span><span style=display:flex><span>          type=<span style=font-style:italic>&#34;text&#34;</span>
</span></span><span style=display:flex><span>          placeholder=<span style=font-style:italic>&#34;Enter your name&#34;</span>
</span></span><span style=display:flex><span>          disabled
</span></span><span style=display:flex><span>          className=<span style=font-style:italic>&#34;view-input&#34;</span>
</span></span><span style=display:flex><span>        /&gt;
</span></span><span style=display:flex><span>      )}
</span></span><span style=display:flex><span>    &lt;/<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The interesting behavior occurs when you interact with this form. If you type something into the input field while editing and then click the &ldquo;Cancel&rdquo; button, your text remains when you click &ldquo;Edit&rdquo; again! This happens even though the two <code>input</code> elements have different props (one is disabled with a different class).</p><p>React preserves the DOM element and its state because both elements are of the same type (<code>input</code>) at the same position in the element tree. React simply updates the props of the existing element rather than recreating it.</p><p>But if we changed our implementation to:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>{
</span></span><span style=display:flex><span>  isEditing ? (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>input</span> type=<span style=font-style:italic>&#34;text&#34;</span> placeholder=<span style=font-style:italic>&#34;Enter your name&#34;</span> className=<span style=font-style:italic>&#34;edit-input&#34;</span> /&gt;
</span></span><span style=display:flex><span>  ) : (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>div</span> className=<span style=font-style:italic>&#34;view-only-display&#34;</span>&gt;Name will appear here&lt;/<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then toggling the edit mode would result in completely different elements being mounted and unmounted, with any user input being lost.</p><p>This behavior highlights a fundamental aspect of React&rsquo;s reconciliation: <strong>element type is the primary factor in determining identity</strong>. Understanding this concept is key to mastering React performance.</p><h2 id=element-trees-not-virtual-dom>Element Trees, Not Virtual DOM
<a class=heading-link href=#element-trees-not-virtual-dom><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>You&rsquo;ve probably heard that React uses a &ldquo;Virtual DOM&rdquo; to optimize updates. While this is a useful mental model, it&rsquo;s more accurate to think of React&rsquo;s internal representation as an element tree - a lightweight description of what should be on screen.</p><p>When you write JSX like this:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> Component = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>h1</span>&gt;Hello&lt;/<span style=font-weight:700>h1</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>p</span>&gt;World&lt;/<span style=font-weight:700>p</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>React transforms it into a tree of plain JavaScript objects:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=font-weight:700>type</span>: <span style=font-style:italic>&#39;div&#39;</span>,
</span></span><span style=display:flex><span>  props: {
</span></span><span style=display:flex><span>    children: [
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=font-weight:700>type</span>: <span style=font-style:italic>&#39;h1&#39;</span>,
</span></span><span style=display:flex><span>        props: {
</span></span><span style=display:flex><span>          children: <span style=font-style:italic>&#39;Hello&#39;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=font-weight:700>type</span>: <span style=font-style:italic>&#39;p&#39;</span>,
</span></span><span style=display:flex><span>        props: {
</span></span><span style=display:flex><span>          children: <span style=font-style:italic>&#39;World&#39;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For DOM elements like <code>div</code> or <code>input</code>, the &ldquo;type&rdquo; is a string. For custom React components, the &ldquo;type&rdquo; is the actual function reference:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=font-weight:700>type</span>: Input, <span style=font-style:italic>// Reference to the Input function itself
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  props: {
</span></span><span style=display:flex><span>    id: <span style=font-style:italic>&#34;company-tax-id&#34;</span>,
</span></span><span style=display:flex><span>    placeholder: <span style=font-style:italic>&#34;Enter company Tax ID&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=how-reconciliation-works>How Reconciliation Works
<a class=heading-link href=#how-reconciliation-works><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>When React needs to update the UI (after state changes or a re-render), it:</p><ol><li>Creates a new element tree by calling your components</li><li>Compares it with the previous tree</li><li>Figures out what DOM operations are needed to make the real DOM match the new tree</li><li>Performs those operations efficiently</li></ol><p>The comparison algorithm follows these key principles:</p><h3 id=1-element-type-determines-identity>1. Element Type Determines Identity
<a class=heading-link href=#1-element-type-determines-identity><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>React first checks the &ldquo;type&rdquo; of elements. If the type changes, React rebuilds the entire subtree:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-style:italic>// From this (first render)
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>&lt;<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=font-weight:700>Counter</span> /&gt;
</span></span><span style=display:flex><span>&lt;/<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic>// To this (second render)
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>&lt;<span style=font-weight:700>span</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=font-weight:700>Counter</span> /&gt;
</span></span><span style=display:flex><span>&lt;/<span style=font-weight:700>span</span>&gt;
</span></span></code></pre></div><p>Since <code>div</code> changed to <code>span</code>, React destroys the entire old tree (including <code>Counter</code>) and builds a new one from scratch.</p><h3 id=2-position-in-the-tree-matters>2. Position in the Tree Matters
<a class=heading-link href=#2-position-in-the-tree-matters><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>React compares elements at the same position in the tree:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-style:italic>// Before
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>&lt;&gt;
</span></span><span style=display:flex><span>  {showDetails ? &lt;<span style=font-weight:700>UserProfile</span> userId={123} /&gt; : &lt;<span style=font-weight:700>LoginPrompt</span> /&gt;}
</span></span><span style=display:flex><span>&lt;/&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic>// After (when showDetails changes)
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>&lt;&gt;
</span></span><span style=display:flex><span>  {showDetails ? &lt;<span style=font-weight:700>UserProfile</span> userId={123} /&gt; : &lt;<span style=font-weight:700>LoginPrompt</span> /&gt;}
</span></span><span style=display:flex><span>&lt;/&gt;
</span></span></code></pre></div><p>In this conditional example, when <code>showDetails</code> is <code>true</code>, there&rsquo;s a <code>UserProfile</code> element at position 1. When it&rsquo;s <code>false</code>, there&rsquo;s a <code>LoginPrompt</code> at position 1. React sees different component types at the same position, so it unmounts one and mounts the other.</p><p>But if we had two components of the same type:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-style:italic>// Before
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>&lt;&gt;
</span></span><span style=display:flex><span>  {isPrimary ? (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>UserProfile</span> userId={123} role=<span style=font-style:italic>&#34;primary&#34;</span> /&gt;
</span></span><span style=display:flex><span>  ) : (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>UserProfile</span> userId={456} role=<span style=font-style:italic>&#34;secondary&#34;</span> /&gt;
</span></span><span style=display:flex><span>  )}
</span></span><span style=display:flex><span>&lt;/&gt;
</span></span></code></pre></div><p>React sees the same component type (<code>UserProfile</code>) at position 1 before and after, so it just updates its props rather than destroying and recreating the component.</p><h3 id=3-keys-override-position-based-comparison>3. Keys Override Position-Based Comparison
<a class=heading-link href=#3-keys-override-position-based-comparison><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>The <code>key</code> attribute lets you override the position-based identity:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>&lt;&gt;
</span></span><span style=display:flex><span>  {isPrimary ? (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>UserProfile</span> key=<span style=font-style:italic>&#34;active-profile&#34;</span> userId={123} role=<span style=font-style:italic>&#34;primary&#34;</span> /&gt;
</span></span><span style=display:flex><span>  ) : (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>UserProfile</span> key=<span style=font-style:italic>&#34;active-profile&#34;</span> userId={456} role=<span style=font-style:italic>&#34;secondary&#34;</span> /&gt;
</span></span><span style=display:flex><span>  )}
</span></span><span style=display:flex><span>&lt;/&gt;
</span></span></code></pre></div><p>Even if the components appear in different branches of the conditional, React will treat them as the same component because they have the same key, preserving state when switching between them.</p><h2 id=the-magic-of-keys>The Magic of Keys
<a class=heading-link href=#the-magic-of-keys><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Keys are primarily known for their role in lists, but they have deeper implications for React&rsquo;s reconciliation process.</p><h3 id=why-keys-are-required-for-lists>Why Keys Are Required for Lists
<a class=heading-link href=#why-keys-are-required-for-lists><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>When rendering lists, React uses keys to track which items have been added, removed, or reordered:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>&lt;<span style=font-weight:700>ul</span>&gt;
</span></span><span style=display:flex><span>  {items.map((item) =&gt; (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>li</span> key={item.id}&gt;{item.text}&lt;/<span style=font-weight:700>li</span>&gt;
</span></span><span style=display:flex><span>  ))}
</span></span><span style=display:flex><span>&lt;/<span style=font-weight:700>ul</span>&gt;
</span></span></code></pre></div><p>Without keys, React would solely rely on the element&rsquo;s position in the array. If you insert a new item at the beginning, React would see every element as having changed position and would rerender the entire list.</p><p>With keys, React can match elements between renders regardless of their position.</p><h3 id=keys-outside-of-arrays>Keys Outside of Arrays?
<a class=heading-link href=#keys-outside-of-arrays><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>React doesn&rsquo;t force you to add keys for static elements:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-style:italic>// No keys needed
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>&lt;&gt;
</span></span><span style=display:flex><span>  &lt;<span style=font-weight:700>Input</span> /&gt;
</span></span><span style=display:flex><span>  &lt;<span style=font-weight:700>Input</span> /&gt;
</span></span><span style=display:flex><span>&lt;/&gt;
</span></span></code></pre></div><p>This works because React knows these elements are static - their position in the tree is predictable.</p><p>But keys can be powerful even outside of lists. Consider this example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> Component = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [isReverse, setIsReverse] = useState(<span style=font-weight:700>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>Input</span> key={isReverse ? <span style=font-style:italic>&#34;some-key&#34;</span> : <span style=font-weight:700>null</span>} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>Input</span> key={!isReverse ? <span style=font-style:italic>&#34;some-key&#34;</span> : <span style=font-weight:700>null</span>} /&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>When <code>isReverse</code> toggles, the key <code>'some-key'</code> moves from one input to the other, causing React to &ldquo;move&rdquo; the component&rsquo;s state between the two positions!</p><h3 id=mixing-dynamic-and-static-elements>Mixing Dynamic and Static Elements
<a class=heading-link href=#mixing-dynamic-and-static-elements><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>A common worry is whether adding items to a dynamic list might shift the identity of static elements after the list:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>&lt;&gt;
</span></span><span style=display:flex><span>  {items.map((item) =&gt; (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>ListItem</span> key={item.id} /&gt;
</span></span><span style=display:flex><span>  ))}
</span></span><span style=display:flex><span>  &lt;<span style=font-weight:700>StaticElement</span> /&gt; {<span style=font-style:italic>/* Will this re-mount if items change? */</span>}
</span></span><span style=display:flex><span>&lt;/&gt;
</span></span></code></pre></div><p>React handles this intelligently. It treats the entire dynamic list as a single unit at the first position, so the <code>StaticElement</code> will always maintain its position and identity, regardless of changes to the list.</p><p>Here&rsquo;s how React actually represents this internally:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span>[
</span></span><span style=display:flex><span>  <span style=font-style:italic>// The entire dynamic array becomes a single child
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  [
</span></span><span style=display:flex><span>    { <span style=font-weight:700>type</span>: ListItem, key: <span style=font-style:italic>&#34;1&#34;</span> },
</span></span><span style=display:flex><span>    { <span style=font-weight:700>type</span>: ListItem, key: <span style=font-style:italic>&#34;2&#34;</span> },
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  { <span style=font-weight:700>type</span>: StaticElement }, <span style=font-style:italic>// Always maintains its second position
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>];
</span></span></code></pre></div><p>Even if you add or remove items from the list, the <code>StaticElement</code> will remain at position 2 in the parent array. This means it won&rsquo;t re-mount when the list changes. This is a clever optimization that ensures static elements don&rsquo;t get unnecessarily re-mounted due to changes in adjacent dynamic lists.</p><h2 id=component-identity-and-performance>Component Identity and Performance
<a class=heading-link href=#component-identity-and-performance><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Understanding these reconciliation details explains several React performance patterns:</p><h3 id=1-why-inline-component-definitions-are-bad>1. Why Inline Component Definitions Are Bad
<a class=heading-link href=#1-why-inline-component-definitions-are-bad><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Defining components inside other components creates new function references on every render:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> Parent = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-style:italic>// Bad practice: InnerComponent recreated on every render
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  <span style=font-weight:700>const</span> InnerComponent = () =&gt; &lt;<span style=font-weight:700>div</span>&gt;Inner content&lt;/<span style=font-weight:700>div</span>&gt;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> &lt;<span style=font-weight:700>InnerComponent</span> /&gt;;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Since the component&rsquo;s &ldquo;type&rdquo; (function reference) changes on every render, React treats it as a completely different component, unmounting and remounting it every time.</p><h3 id=2-why-composition-patterns-work>2. Why Composition Patterns Work
<a class=heading-link href=#2-why-composition-patterns-work><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>The composition pattern from our previous article leverages React&rsquo;s reconciliation algorithm:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> CounterButton = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [count, setCount] = useState(0);
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> &lt;<span style=font-weight:700>button</span> onClick={() =&gt; setCount(count + 1)}&gt;Count: {count}&lt;/<span style=font-weight:700>button</span>&gt;;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> Parent = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>CounterButton</span> /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>ExpensiveComponent</span> /&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>When <code>count</code> changes, only the <code>CounterButton</code> tree needs reconciliation. React doesn&rsquo;t even touch the <code>ExpensiveComponent</code> tree since it&rsquo;s in a separate branch.</p><h3 id=3-using-keys-for-advanced-state-preservation>3. Using Keys for Advanced State Preservation
<a class=heading-link href=#3-using-keys-for-advanced-state-preservation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Based on our understanding of keys, we can implement advanced patterns, but with some important caveats:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> TabContent = ({ activeTab }) =&gt; {
</span></span><span style=display:flex><span>  <span style=font-style:italic>// This approach is INCORRECT and won&#39;t preserve state between different component types
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>      {activeTab === <span style=font-style:italic>&#34;profile&#34;</span> &amp;&amp; &lt;<span style=font-weight:700>ProfileTab</span> key=<span style=font-style:italic>&#34;tab-content&#34;</span> /&gt;}
</span></span><span style=display:flex><span>      {activeTab === <span style=font-style:italic>&#34;settings&#34;</span> &amp;&amp; &lt;<span style=font-weight:700>SettingsTab</span> key=<span style=font-style:italic>&#34;tab-content&#34;</span> /&gt;}
</span></span><span style=display:flex><span>      {activeTab === <span style=font-style:italic>&#34;activity&#34;</span> &amp;&amp; &lt;<span style=font-weight:700>ActivityTab</span> key=<span style=font-style:italic>&#34;tab-content&#34;</span> /&gt;}
</span></span><span style=display:flex><span>    &lt;/<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The above example wouldn&rsquo;t work as one might expect. When the <code>activeTab</code> changes from &ldquo;profile&rdquo; to &ldquo;settings&rdquo;, React will:</p><ol><li>See that the key &ldquo;tab-content&rdquo; exists in both renders</li><li>Notice that the component type changed from <code>ProfileTab</code> to <code>SettingsTab</code></li><li>Unmount the <code>ProfileTab</code> and mount the <code>SettingsTab</code> as a new component</li></ol><p>React identifies components by both key AND type. When the key matches but the type differs, React will still unmount and remount.</p><p>Here&rsquo;s how to correctly preserve state across different UI representations:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-style:italic>// Correct approach: Lift state to a parent component
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>const</span> TabContent = ({ activeTab }) =&gt; {
</span></span><span style=display:flex><span>  <span style=font-style:italic>// State that needs to be preserved across tab changes
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  <span style=font-weight:700>const</span> [sharedState, setSharedState] = useState({
</span></span><span style=display:flex><span>    <span style=font-style:italic>/* initial state */</span>
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>      {activeTab === <span style=font-style:italic>&#34;profile&#34;</span> &amp;&amp; (
</span></span><span style=display:flex><span>        &lt;<span style=font-weight:700>ProfileTab</span> state={sharedState} onStateChange={setSharedState} /&gt;
</span></span><span style=display:flex><span>      )}
</span></span><span style=display:flex><span>      {activeTab === <span style=font-style:italic>&#34;settings&#34;</span> &amp;&amp; (
</span></span><span style=display:flex><span>        &lt;<span style=font-weight:700>SettingsTab</span> state={sharedState} onStateChange={setSharedState} /&gt;
</span></span><span style=display:flex><span>      )}
</span></span><span style=display:flex><span>      {activeTab === <span style=font-style:italic>&#34;activity&#34;</span> &amp;&amp; (
</span></span><span style=display:flex><span>        &lt;<span style=font-weight:700>ActivityTab</span> state={sharedState} onStateChange={setSharedState} /&gt;
</span></span><span style=display:flex><span>      )}
</span></span><span style=display:flex><span>    &lt;/<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Another legitimate use of keys for state preservation is with the same component type:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> UserForm = ({ userId }) =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [formData, setFormData] = useState({});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-style:italic>// This will reset the form when userId changes
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>form</span> key={userId}&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>input</span>
</span></span><span style=display:flex><span>        value={formData.name || <span style=font-style:italic>&#34;&#34;</span>}
</span></span><span style=display:flex><span>        onChange={(e) =&gt; setFormData({ ...formData, name: <span>e.target.value</span> })}
</span></span><span style=display:flex><span>      /&gt;
</span></span><span style=display:flex><span>      {<span style=font-style:italic>/* Other form inputs */</span>}
</span></span><span style=display:flex><span>    &lt;/<span style=font-weight:700>form</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>By giving the form a key based on userId, we ensure that React creates a completely new component instance (with fresh state) whenever the userId changes, which is useful for forms that should reset when editing a different entity.</p><h2 id=state-colocation-a-powerful-performance-pattern>State Colocation: A Powerful Performance Pattern
<a class=heading-link href=#state-colocation-a-powerful-performance-pattern><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>State colocation is a pattern that involves keeping state as close as possible to where it&rsquo;s used. This approach minimizes unnecessary re-renders by ensuring that only the components directly affected by state changes are updated.</p><p>Consider this example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-style:italic>// Poor performance - entire app re-renders when filter changes
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>const</span> App = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [filterText, setFilterText] = useState(<span style=font-style:italic>&#34;&#34;</span>);
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> filteredUsers = users.filter((user) =&gt; user.name.includes(filterText));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>SearchBox</span> filterText={filterText} onChange={setFilterText} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>UserList</span> users={filteredUsers} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>ExpensiveComponent</span> /&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>When <code>filterText</code> changes, the entire <code>App</code> component re-renders, including <code>ExpensiveComponent</code> which isn&rsquo;t affected by the filter.</p><p>By colocating the filter state with just the components that use it:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> UserSection = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [filterText, setFilterText] = useState(<span style=font-style:italic>&#34;&#34;</span>);
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> filteredUsers = users.filter((user) =&gt; user.name.includes(filterText));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>SearchBox</span> filterText={filterText} onChange={setFilterText} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>UserList</span> users={filteredUsers} /&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> App = () =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>UserSection</span> /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>ExpensiveComponent</span> /&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Now when the filter changes, only <code>UserSection</code> re-renders. This pattern not only improves performance but also leads to better component design by ensuring each component only manages the state that truly belongs to it.</p><h2 id=component-design-optimizing-for-change>Component Design: Optimizing for Change
<a class=heading-link href=#component-design-optimizing-for-change><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Performance optimization is often a component design problem. If a component does too many things, it&rsquo;s more likely to re-render unnecessarily.</p><p>Before reaching for <code>React.memo</code>, ask:</p><ol><li><p><strong>Does this component have mixed responsibilities?</strong> Components that handle multiple concerns are likely to re-render more frequently.</p></li><li><p><strong>Is state being lifted too high?</strong> When state is kept higher in the tree than needed, it causes more components to re-render.</p></li></ol><p>Consider this example:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-style:italic>// Problematic design - mixed concerns
</span></span></span><span style=display:flex><span><span style=font-style:italic></span><span style=font-weight:700>const</span> ProductPage = ({ productId }) =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [selectedSize, setSelectedSize] = useState(<span style=font-style:italic>&#34;medium&#34;</span>);
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [quantity, setQuantity] = useState(1);
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [shipping, setShipping] = useState(<span style=font-style:italic>&#34;express&#34;</span>);
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [reviews, setReviews] = useState([]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-style:italic>// Fetches both product details and reviews
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>  useEffect(() =&gt; {
</span></span><span style=display:flex><span>    fetchProductDetails(productId);
</span></span><span style=display:flex><span>    fetchReviews(productId).then(setReviews);
</span></span><span style=display:flex><span>  }, [productId]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>ProductInfo</span>
</span></span><span style=display:flex><span>        selectedSize={selectedSize}
</span></span><span style=display:flex><span>        onSizeChange={setSelectedSize}
</span></span><span style=display:flex><span>        quantity={quantity}
</span></span><span style=display:flex><span>        onQuantityChange={setQuantity}
</span></span><span style=display:flex><span>      /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>ShippingOptions</span> shipping={shipping} onShippingChange={setShipping} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>Reviews</span> reviews={reviews} /&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Every time the size, quantity, or shipping changes, the entire page re-renders, including the unrelated reviews section.</p><p>A better design separates these concerns:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-tsx data-lang=tsx><span style=display:flex><span><span style=font-weight:700>const</span> ProductPage = ({ productId }) =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>ProductConfig</span> productId={productId} /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>ReviewsSection</span> productId={productId} /&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=font-weight:700>div</span>&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> ProductConfig = ({ productId }) =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [selectedSize, setSelectedSize] = useState(<span style=font-style:italic>&#34;medium&#34;</span>);
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [quantity, setQuantity] = useState(1);
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [shipping, setShipping] = useState(<span style=font-style:italic>&#34;express&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-style:italic>// Product-specific logic
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> (
</span></span><span style=display:flex><span>    &lt;&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>ProductInfo</span>
</span></span><span style=display:flex><span>        selectedSize={selectedSize}
</span></span><span style=display:flex><span>        onSizeChange={setSelectedSize}
</span></span><span style=display:flex><span>        quantity={quantity}
</span></span><span style=display:flex><span>        onQuantityChange={setQuantity}
</span></span><span style=display:flex><span>      /&gt;
</span></span><span style=display:flex><span>      &lt;<span style=font-weight:700>ShippingOptions</span> shipping={shipping} onShippingChange={setShipping} /&gt;
</span></span><span style=display:flex><span>    &lt;/&gt;
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>const</span> ReviewsSection = ({ productId }) =&gt; {
</span></span><span style=display:flex><span>  <span style=font-weight:700>const</span> [reviews, setReviews] = useState([]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  useEffect(() =&gt; {
</span></span><span style=display:flex><span>    fetchReviews(productId).then(setReviews);
</span></span><span style=display:flex><span>  }, [productId]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>return</span> &lt;<span style=font-weight:700>Reviews</span> reviews={reviews} /&gt;;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>This structure ensures that changing the product size doesn&rsquo;t cause the reviews to re-render. No memoization needed - just good component boundaries.</p><h2 id=reconciliation-and-clean-architecture>Reconciliation and Clean Architecture
<a class=heading-link href=#reconciliation-and-clean-architecture><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>This understanding of reconciliation aligns perfectly with Clean Architecture principles:</p><ol><li><p><strong>Single Responsibility Principle</strong>: Each component should have one reason to change. When components are focused on a single responsibility, they&rsquo;re less likely to trigger unnecessary re-renders.</p></li><li><p><strong>Dependency Inversion</strong>: Components should depend on abstractions, not concrete implementations. This makes it easier to optimize performance through composition.</p></li><li><p><strong>Interface Segregation</strong>: Components should have minimal, focused interfaces. This reduces the chance of prop changes triggering unnecessary re-renders.</p></li></ol><h2 id=practical-guidelines>Practical Guidelines
<a class=heading-link href=#practical-guidelines><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Based on our deep dive into reconciliation, here are some practical guidelines:</p><ol><li><p><strong>Keep component definitions outside parent components</strong> to prevent remounting.</p></li><li><p><strong>Move state down</strong> to isolate re-render boundaries.</p></li><li><p><strong>Be consistent with component types</strong> in the same position to avoid unmounting.</p></li><li><p><strong>Use keys strategically</strong> - not just for lists, but whenever you want to control component identity.</p></li><li><p><strong>When debugging re-render issues</strong>, think in terms of element trees and component identity.</p></li><li><p><strong>Remember that React.memo is just a tool</strong> that works within the constraints of reconciliation - it doesn&rsquo;t change the fundamental algorithm.</p></li></ol><h2 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Understanding React&rsquo;s reconciliation algorithm reveals the &ldquo;why&rdquo; behind many React performance patterns. It explains why composition works so well, why we need keys for lists, and why defining components inside other components is problematic.</p><p>This knowledge helps us make better architectural decisions that naturally lead to performant React applications. Rather than fighting React&rsquo;s reconciliation algorithm with excessive memoization, we can work with it by designing component structures that align with how React identifies and updates components.</p><p>The next time you&rsquo;re optimizing a React application, think about how your component structure affects the reconciliation process. Sometimes, the best optimization is a simpler, more focused component tree that respects how React identifies and updates components.</p><p>What patterns have you found most effective for working with React&rsquo;s reconciliation process? I&rsquo;d love to hear your experiences, use the Feedback.One button on the right ðŸ¤“</p></div><footer></footer></article></section></div><script type=text/javascript src=https://testimonial.to/js/iframeResizer.min.js></script><style>form{display:flex;justify-content:center}</style><form action="https://api.follow.it/subscription-form/SDRVMUk2VmsySENBNk94RDNKNDFnS3NmWlQ5a3gxejNIeUlJWHl3QjdqNnRHdENkaXp5aXZhZlFvcGtzcEZ3K0o5TFVRdSt2WWM5RWRsWmZwWVhNUS9PZjJqMWZ3aHBwZUhjT1ZpWXBGRkdZOWtIcGhYQkJkSkE4QTQ1eHl5YkF8RTZHTExQOWFrN1pFY1F0RzZ5c3pVN2I1QTI1YXNtMjZiYllLU25zQkJ3bz0=/8" method=post><input type=email name=email required placeholder=Email spellcheck=false>
<button type=submit>Subscribe</button></form><div id=testemonials class=container style="background:#fff!important;clip-path:inset(0 0 90px 0);padding:24px;border-radius:24px;opacity:0;max-height:0;transition:opacity 1s,max-height 1s"><iframe id=testimonialto-carousel-christian-ekrem-tag-all-light src="https://embed-v2.testimonial.to/carousel/all/christian-ekrem?theme=light&autoplay=off&showmore=on&one-row=on&hideDate=off&same-height=off&tag=all&arrowColor=9BA9B4" frameborder=0 scrolling=no width=100%></iframe></div><script type=text/javascript>location.pathname in{"":!0,"/":!0,"/hire/":!0,"/hire":!0}&&setTimeout(()=>{iFrameResize({log:!1,checkOrigin:!1},"#testimonialto-carousel-christian-ekrem-tag-all-light");const e=document.getElementById("testemonials");e.style.display="block",e.style.opacity=1,e.style.maxHeight="600px"},1e3)</script><footer class=footer><section class=container>Â© 2021 - 2025 Christian Ekrem
<script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-emoji=ðŸº data-id=cekrem data-description="Support me on Buy me a coffee!" data-message data-color=#ddd data-position=Right data-x_margin=18 data-y_margin=18></script></section><script src=https://formspree.io/js/formbutton-v1.min.js defer></script></footer><script src=https://sdk.feedback.one/v0/core.min.js data-project-id=019589e0-c6fb-7b80-b6ae-dffbfbb11f72 defer></script></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script data-goatcounter=https://cekrem.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>