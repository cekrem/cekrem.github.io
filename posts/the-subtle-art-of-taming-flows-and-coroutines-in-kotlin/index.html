<!doctype html><html lang=en><head><title>The Subtle Art of Taming Flows and Coroutines in Kotlin, or 'How Not to DDoS Yourself with Server-Sent Events' Â· cekrem.github.io</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Christian Ekrem"><meta name=description content="A tale of how elegant SSE code passed code review, worked perfectly locally and in staging, but nearly brought down our production servers when thousands of users connected simultaneously during a real DDoS attack."><meta name=keywords content="developer,personal"><meta name=fediverse:creator content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cekrem.github.io/images/banner.jpg"><meta name=twitter:title content="The Subtle Art of Taming Flows and Coroutines in Kotlin, or 'How Not to DDoS Yourself with Server-Sent Events'"><meta name=twitter:description content="A tale of how elegant SSE code passed code review, worked perfectly locally and in staging, but nearly brought down our production servers when thousands of users connected simultaneously during a real DDoS attack."><meta property="og:url" content="https://cekrem.github.io/posts/the-subtle-art-of-taming-flows-and-coroutines-in-kotlin/"><meta property="og:site_name" content="cekrem.github.io"><meta property="og:title" content="The Subtle Art of Taming Flows and Coroutines in Kotlin, or 'How Not to DDoS Yourself with Server-Sent Events'"><meta property="og:description" content="A tale of how elegant SSE code passed code review, worked perfectly locally and in staging, but nearly brought down our production servers when thousands of users connected simultaneously during a real DDoS attack."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-08T00:00:00+00:00"><meta property="article:modified_time" content="2025-09-08T00:00:00+00:00"><meta property="article:tag" content="Kotlin"><meta property="article:tag" content="Ktor"><meta property="article:tag" content="Server-Sent-Events"><meta property="article:tag" content="Coroutines"><meta property="article:tag" content="Flow"><meta property="article:tag" content="Performance"><meta property="og:image" content="https://cekrem.github.io/images/banner.jpg"><link rel=canonical href=https://cekrem.github.io/posts/the-subtle-art-of-taming-flows-and-coroutines-in-kotlin/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.e8eb08b92eec0f2a19c8cbe4eda1f38c703416996d08f55900541ba798921e5b.css integrity="sha256-6OsIuS7sDyoZyMvk7aHzjHA0FpltCPVZAFQbp5iSHls=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a93347c2833a476d1c25ae74bed3f80024fc1eaf1a33d084c2211065513e5c42.css integrity="sha256-qTNHwoM6R20cJa50vtP4ACT8Hq8aM9CEwiEQZVE+XEI=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://cekrem.github.io/>cekrem.github.io
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/how-i-met-jesus/>Jesus!?</a></li><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/books-i-think-software-engineers-should-read>Recommended Books</a></li><li class=navigation-item><a class=navigation-link href=https://creators.spotify.com/pod/show/disippel>Podcast (ðŸ‡³ðŸ‡´)</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://cekrem.github.io/posts/the-subtle-art-of-taming-flows-and-coroutines-in-kotlin/>The Subtle Art of Taming Flows and Coroutines in Kotlin, or 'How Not to DDoS Yourself with Server-Sent Events'</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-09-08T00:00:00Z>September 8, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
7-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/kotlin/>Kotlin</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/ktor/>Ktor</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/server-sent-events/>Server-Sent-Events</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/coroutines/>Coroutines</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/flow/>Flow</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/performance/>Performance</a>
</span><span class=separator>â€¢</span>
<span class=tag><a href=/tags/production/>Production</a></span></div></div></header><div class=post-content><p>I originally wanted to write a post about Server-Sent Events in general, and how delightfully cool they are. SSE provides a clean, standardized way for servers to push real-time updates to web clients over a simple HTTP connection. The <a href=https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events class=external-link target=_blank rel=noopener>MDN documentation</a> showcases how straightforward the client-side implementation is, while <a href=https://ktor.io/docs/server-server-sent-events.html class=external-link target=_blank rel=noopener>Ktor&rsquo;s SSE support</a> makes the server-side equally elegant. SSE strikes a perfect balance: simpler than WebSockets when you only need one-way communication, yet more efficient than polling.</p><p>But this isn&rsquo;t that post.</p><p>Instead, this is a story about how seemingly innocent Flow and coroutine code can bite you in production in the most unexpected ways. It&rsquo;s about the subtle difference between &ldquo;working&rdquo; and &ldquo;working under load.&rdquo; And it&rsquo;s about how a tiny change in flow control can mean the difference between a robust server and an accidental self-DDoS.</p><p><strong>Note: I tell this tale with the explicit permission from my client, but I&rsquo;ve intentionally obfuscated some details for obvious reasons.</strong></p><h2 id=the-setup-a-perfect-storm>The Setup: A Perfect Storm
<a class=heading-link href=#the-setup-a-perfect-storm><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Picture this: It&rsquo;s a Friday around lunch-time. Our team has just deployed a beautiful new SSE endpoint for real-time notifications. The code passed code review with flying colors, worked flawlessly in local development, and sailed through our staging environment. We were proud of our clean, idiomatic Kotlinâ€”a textbook example of modern coroutine and Flow usage.</p><p>Then we deployed to production.</p><p>At the exact same time, a known hacker group decided to launch a DDoS attack against our infrastructure. Thousands of legitimate users were online, each with active SSE connections for real-time updates. The combination of external attack traffic and internal connection management created the perfect storm.</p><p>Our servers didn&rsquo;t just struggleâ€”they started consuming resources at an alarming rate. Memory usage spiked, CPU utilization maxed out, and we were essentially DDoS&rsquo;ing ourselves from the inside while fighting off the external attack.</p><h2 id=the-puzzle-two-approaches-one-problem>The Puzzle: Two Approaches, One Problem
<a class=heading-link href=#the-puzzle-two-approaches-one-problem><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Here&rsquo;s the code that went to production. Can you spot which approach will leak resources under load?</p><h3 id=approach-a-collect--return>Approach A: Collect & Return
<a class=heading-link href=#approach-a-collect--return><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>routing {
</span></span><span style=display:flex><span>    sse(<span style=color:#5af78e>&#34;/events&#34;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> sessionId = call.sessionId()
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> eventFlow: Flow&lt;Pair&lt;String, Boolean&gt; = merge(someGlobalEventFlow, someClientSpecificEventFlow(sessionId))
</span></span><span style=display:flex><span>            .map { event <span style=color:#ff6ac1>-&gt;</span> Pair(event, checkIfClientIsAuthenticated(sessionId)) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e>// Approach A: collect &amp;&amp; return
</span></span></span><span style=display:flex><span>        eventFlow.collect { (event, clientIsAuthenticated) <span style=color:#ff6ac1>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#78787e>// if the client is not authenticated, return from function to stop collecting events
</span></span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (!clientIsAuthenticated) {
</span></span><span style=display:flex><span>                sendLoggedOutEvent()
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>return</span><span style=color:#ff9f43>@collect</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#78787e>// try to send the event to the client, returning true if the client is still connected
</span></span></span><span style=display:flex><span>            <span style=color:#ff6ac1>val</span> clientIsConnected = trySendEvent(event)
</span></span><span style=display:flex><span>            <span style=color:#ff6ac1>if</span> (!clientIsConnected) {
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>return</span><span style=color:#ff9f43>@collect</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e>// home free: no longer trying to send events to this user
</span></span></span><span style=display:flex><span>        close()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=approach-b-collect--cancel>Approach B: Collect & Cancel
<a class=heading-link href=#approach-b-collect--cancel><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>routing {
</span></span><span style=display:flex><span>    sse(<span style=color:#5af78e>&#34;/events&#34;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> sessionId = call.sessionId()
</span></span><span style=display:flex><span>        <span style=color:#ff6ac1>val</span> eventFlow: Flow&lt;Pair&lt;String, Boolean&gt; = merge(someGlobalEventFlow, someClientSpecificEventFlow(sessionId))
</span></span><span style=display:flex><span>            .map { event <span style=color:#ff6ac1>-&gt;</span> Pair(event, checkIfClientIsAuthenticated(sessionId)) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e>// Approach B: collect &amp;&amp; cancel
</span></span></span><span style=display:flex><span>        <span style=color:#ff6ac1>try</span> {
</span></span><span style=display:flex><span>            eventFlow.collect { (event, clientIsAuthenticated) <span style=color:#ff6ac1>-&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#78787e>// if the client is not authenticated, cancel the flow to stop collecting events
</span></span></span><span style=display:flex><span>                <span style=color:#ff6ac1>if</span> (!clientIsAuthenticated) {
</span></span><span style=display:flex><span>                    sendLoggedOutEvent()
</span></span><span style=display:flex><span>                    cancel(IntentionalCloseException)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#78787e>// try to send the event to the client, returning true if the client is still connected
</span></span></span><span style=display:flex><span>                <span style=color:#ff6ac1>val</span> clientIsConnected = trySendEvent(event)
</span></span><span style=display:flex><span>                <span style=color:#ff6ac1>if</span> (!clientIsConnected) {
</span></span><span style=display:flex><span>                    cancel(IntentionalCloseException)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#ff6ac1>catch</span> (e: IntentionalCloseException) {
</span></span><span style=display:flex><span>            <span style=color:#78787e>// do nothing, we&#39;ve cancelled the flow intentionally
</span></span></span><span style=display:flex><span>        } <span style=color:#ff6ac1>finally</span> {
</span></span><span style=display:flex><span>            <span style=color:#78787e>// home free: no longer trying to send events to this user
</span></span></span><span style=display:flex><span>            close()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Both approaches look reasonable at first glance. Both handle authentication checking and client disconnection. Both compile cleanly and work perfectly with a handful of concurrent connections.</p><p>But only one of them will behave correctly under production load.</p><h2 id=the-difference-a-tale-of-two-control-flows>The Difference: A Tale of Two Control Flows
<a class=heading-link href=#the-difference-a-tale-of-two-control-flows><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The critical difference lies in how each approach handles early termination of the Flow collection.</p><h3 id=approach-a-the-resource-leak>Approach A: The Resource Leak
<a class=heading-link href=#approach-a-the-resource-leak><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>if</span> (!clientIsAuthenticated) {
</span></span><span style=display:flex><span>    <span style=color:#ff6ac1>return</span><span style=color:#ff9f43>@collect</span>  <span style=color:#78787e>// This only skips the current emission!
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here&rsquo;s the subtle trap: <code>return@collect</code> doesn&rsquo;t stop the collectionâ€”it only skips processing the current emission. The <code>collect</code> block continues waiting for the next emission from the Flow. This means:</p><ol><li>The coroutine keeps running</li><li>The SSE connection remains open</li><li>The Flow continues producing events</li><li><code>close()</code> is never reached</li><li>Resources accumulate with each &ldquo;disconnected&rdquo; client</li></ol><p>So while the <code>return@collect</code> <em>appears</em> to be the coroutine equivalent of a <code>break</code> within a regular loop, it&rsquo;s actually more similar to a <code>continue</code>. Precicely what we <em>don&rsquo;t</em> want!</p><p>Under normal conditions with a few dozen connections, this might go unnoticed (and it sure did!). But when thousands of connections are established during a DDoS attack and then clients become unauthenticated or disconnect, those zombie collectors pile up quickly. Very quickly!</p><h3 id=approach-b-clean-termination>Approach B: Clean Termination
<a class=heading-link href=#approach-b-clean-termination><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff6ac1>if</span> (!clientIsAuthenticated) {
</span></span><span style=display:flex><span>    cancel(IntentionalCloseException)  <span style=color:#78787e>// This cancels the collecting coroutine; think `break` within a loop
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>cancel()</code> call throws a <code>IntentionalCloseException</code>, which:</p><ol><li>Terminates the collecting coroutine</li><li>Exits the <code>collect</code> block</li><li>Triggers the <code>finally</code> block</li><li>Calls <code>close()</code> to clean up the SSE connection</li><li>Properly releases all associated resources</li></ol><p>The <code>try-catch-finally</code> structure ensures that when we intentionally cancel the operation, cleanup happens correctly.</p><p>(You could also use some variation of <code>transformWhile</code> or <code>takeWhile</code> before the collect instead of canceling with an exception, which is what we ended up doing. But try/catch/finally was easier to explain.)</p><h2 id=the-production-reality>The Production Reality
<a class=heading-link href=#the-production-reality><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>During our incident, Approach A created a cascading resource leak. Every time a client disconnected or became unauthenticated (which happened frequently during the DDoS), we accumulated:</p><ul><li>An active coroutine waiting for the next Flow emission</li><li>An open SSE connection consuming server resources</li><li>Memory allocated for the Flow processing pipeline</li><li>Background tasks polling for authentication status</li></ul><p>With thousands of connections being established and &ldquo;abandoned&rdquo; in this way, our servers quickly became overwhelmedâ€”not just by the external attack, but by our own leaked resources.</p><h2 id=the-fix-and-lessons-learned>The Fix and Lessons Learned
<a class=heading-link href=#the-fix-and-lessons-learned><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The fix was embarrassingly simple: replace <code>return@collect</code> with <code>cancel(...)</code> and add proper exception handling. But the lessons were profound:</p><h3 id=1-load-testing-reveals-truth>1. Load Testing Reveals Truth
<a class=heading-link href=#1-load-testing-reveals-truth><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Code that works with 10 concurrent connections might fail catastrophically with 10,000. Our staging environment, optimized for cost over scale, simply couldn&rsquo;t reproduce the production load patterns.</p><h3 id=2-resource-management-is-critical>2. Resource Management Is Critical
<a class=heading-link href=#2-resource-management-is-critical><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>In languages with garbage collection, it&rsquo;s easy to forget about resource leaks. But when dealing with network connections, coroutines, and flows, explicit cleanup becomes crucial.</p><h3 id=3-control-flow-matters>3. Control Flow Matters
<a class=heading-link href=#3-control-flow-matters><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>The difference between &ldquo;skip this iteration&rdquo; and &ldquo;stop collecting&rdquo; is subtle in code (and in this case <em>very</em> easy to miss!) but massive in production impact. Understanding the exact semantics of coroutine cancellation is essential for robust server applications.</p><h3 id=4-timing-is-everything>4. Timing Is Everything
<a class=heading-link href=#4-timing-is-everything><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Our code worked perfectlyâ€”until it didn&rsquo;t. The combination of high load and external pressure revealed edge cases that never appeared under normal conditions.</p><h2 id=best-practices-for-sse-and-flow-management>Best Practices for SSE and Flow Management
<a class=heading-link href=#best-practices-for-sse-and-flow-management><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><ol><li><strong>Always use explicit cancellation</strong> when you need to terminate Flow collection early</li><li><strong>Implement proper cleanup</strong> in <code>finally</code> blocks or using <code>use</code> functions</li><li><strong>Test under realistic load</strong> with tools that can simulate thousands of concurrent connections</li><li><strong>Monitor resource usage</strong> in production to catch accumulation patterns early</li><li><strong>Understand coroutine lifecycle</strong> and how cancellation propagates through your system</li></ol><h2 id=a-happy-ending>A Happy Ending
<a class=heading-link href=#a-happy-ending><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>After deploying the fix, our servers stabilized even under the continued DDoS attack. The external attackers were eventually blocked, but more importantly, we learned that our internal code was resilient under extreme load.</p><p>The corrected approach handles thousands of SSE connections gracefully, properly cleaning up resources when clients disconnect, and maintaining predictable memory usage even under attack conditions.</p><h2 id=conclusion>Conclusion
<a class=heading-link href=#conclusion><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Server-Sent Events are indeed a powerful and elegant technology for real-time web applications. Kotlin&rsquo;s coroutines and Flow provide beautiful abstractions for handling asynchronous streams. But excellence, as always, is in the details.</p><p>The difference between <code>return@collect</code> and <code>cancel(...)</code> might seem trivial, but in production systems serving thousands of users, these subtleties become the difference between stability and catastrophic failure.</p><p>Sometimes the most dangerous bugs are the ones that hide in plain sight, looking perfectly reasonable until the moment they&rsquo;re not.</p><p>Remember: when dealing with flows and coroutines, always clean up your resources. Your production servers will thank you.</p><hr><p><em>Special thanks to the DDoS attackers for providing the load testing we apparently needed. Your service is not requested, but occasionally educational.</em></p></div><footer></footer></article></section></div><style>form{display:flex;justify-content:center}</style><form action="https://api.follow.it/subscription-form/SDRVMUk2VmsySENBNk94RDNKNDFnS3NmWlQ5a3gxejNIeUlJWHl3QjdqNnRHdENkaXp5aXZhZlFvcGtzcEZ3K0o5TFVRdSt2WWM5RWRsWmZwWVhNUS9PZjJqMWZ3aHBwZUhjT1ZpWXBGRkdZOWtIcGhYQkJkSkE4QTQ1eHl5YkF8RTZHTExQOWFrN1pFY1F0RzZ5c3pVN2I1QTI1YXNtMjZiYllLU25zQkJ3bz0=/8" method=post onsubmit=onSubscribe()><input type=email name=email required placeholder=Email spellcheck=false style="padding:1rem;border:none;border-radius:1rem 0 0 1rem;outline:none">
<button type=submit style="border:none;border-radius:0 1rem 1rem 0;outline:none;background:rgba(127,127,127,5%);cursor:pointer">
Subscribe</button></form><div id=elm-widget></div><script src=/widget.js></script><script>Elm.Main.init({node:document.getElementById("elm-widget"),flags:window.location.pathname})</script><script type=text/javascript src="https://platform-api.sharethis.com/js/sharethis.js#property=6834b86198608700128c9ffa&product=sticky-share-buttons" async></script><footer class=footer><section class=container>Â© 2021 - 2026 Christian Ekrem
<script data-name=BMC-Widget data-cfasync=false src=https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js data-emoji=ðŸº data-id=cekrem data-description="Support me on Buy me a coffee!" data-message data-color=#ddd data-position=Left data-x_margin=18 data-y_margin=18></script></section><script src=https://formspree.io/js/formbutton-v1.min.js defer></script></footer><script src=https://sdk.feedback.one/v0/core.min.js data-project-id=019589e0-c6fb-7b80-b6ae-dffbfbb11f72 defer></script><script src=/secret-sauce-holy-oil.js defer async></script><script>!function(e,t){var n,s,o,i;t.__SV||window.posthog&&window.posthog.__loaded||(window.posthog=t,t._i=[],t.init=function(a,r,c){function d(e,t){var n=t.split(".");2==n.length&&(e=e[n[0]],t=n[1]),e[t]=function(){e.push([t].concat(Array.prototype.slice.call(arguments,0)))}}(n=e.createElement("script")).type="text/javascript",n.crossOrigin="anonymous",n.async=!0,n.src=r.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(i=e.getElementsByTagName("script")[0]).parentNode.insertBefore(n,i);var l=t;for(0[0]!==c?l=t[c]=[]:c="posthog",l.people=l.people||[],l.toString=function(e){var t="posthog";return"posthog"!==c&&(t+="."+c),e||(t+=" (stub)"),t},l.people.toString=function(){return l.toString(1)+".people (stub)"},o="init Rr Mr fi Or Ar ci Tr Cr capture Mi calculateEventProperties Lr register register_once register_for_session unregister unregister_for_session Hr getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey displaySurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty Ur jr createPersonProfile zr kr Br opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing get_explicit_consent_status is_capturing clear_opt_in_out_capturing Dr debug M Nr getPageViewId captureTraceFeedback captureTraceMetric $r".split(" "),s=0;s<o.length;s++)d(l,o[s]);t._i.push([a,r,c])},t.__SV=1)}(document,window.posthog||[]),posthog.init("phc_AHy7NSMntJJLr0hUSCwdUS1eRq6SaEqacK1Mzzf36ED",{api_host:"https://eu.i.posthog.com",defaults:"2025-05-24",person_profiles:"identified_only"});function onSubscribe(){posthog.capture("new subscriber")}</script></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script data-goatcounter=https://cekrem.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>