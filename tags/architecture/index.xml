<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Architecture on cekrem.github.io</title><link>https://cekrem.github.io/tags/architecture/</link><description>Recent content in Architecture on cekrem.github.io</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 14 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://cekrem.github.io/tags/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Elm Land, Shared Subscriptions, and the Art of Workarounds</title><link>https://cekrem.github.io/posts/elm-land-shared-subscriptions-and-the-art-of-workarounds/</link><pubDate>Tue, 14 Oct 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/elm-land-shared-subscriptions-and-the-art-of-workarounds/</guid><description>&lt;h2 id="the-problem-that-shouldnt-exist"&gt;
 The Problem That Shouldn&amp;rsquo;t Exist
 &lt;a class="heading-link" href="#the-problem-that-shouldnt-exist"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Here&amp;rsquo;s a question that comes up occasionally in Elm Land projects: &lt;em&gt;How do I react when something in the &lt;code&gt;Shared&lt;/code&gt; model changes?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;It sounds simple enough. You have some global state in &lt;code&gt;Shared.Model&lt;/code&gt; - maybe feature flags loaded from the backend, authentication status, or some configuration data. Your page needs to &lt;em&gt;do something&lt;/em&gt; when that data changes. Not just render differently (that&amp;rsquo;s trivial), but actually perform an effect - fire off a new HTTP request, trigger some side effect locally, or whatever.&lt;/p&gt;</description></item><item><title>The Discipline of Constraints: What Elm Taught Me About React's useReducer</title><link>https://cekrem.github.io/posts/the-discipline-of-constraints-elm-usereducer-lessons/</link><pubDate>Thu, 18 Sep 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/the-discipline-of-constraints-elm-usereducer-lessons/</guid><description>&lt;h2 id="the-accidental-teacher"&gt;
 The Accidental Teacher
 &lt;a class="heading-link" href="#the-accidental-teacher"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;ve been thinking about discipline lately. Not the &amp;ldquo;wake up at 5 AM and eat nothing but kale&amp;rdquo; kind, but the more interesting variety: the kind that comes from working within constraints that make bad choices impossible.&lt;/p&gt;
&lt;p&gt;After spending several months deep in Elm land - where the compiler is your strict but helpful mentor - I returned to a React codebase that was enthusiastically using &lt;code&gt;useReducer&lt;/code&gt; everywhere. The whiplash was immediate and instructive.&lt;/p&gt;</description></item><item><title>On the Value of Abstractions</title><link>https://cekrem.github.io/posts/on-the-value-of-abstractions/</link><pubDate>Thu, 07 Aug 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/on-the-value-of-abstractions/</guid><description>&lt;p&gt;Most of my day-to-day work is in Elm. The combination of a functional language and the Elm Architecture makes many architectural decisions almost invisible (I talk more about that &lt;a href="https://cekrem.github.io/posts/why-i-hope-i-get-to-write-a-lot-of-elm-code-in-2025/#the-elm-architecture-vs-clean-architecture" &gt;in this blog post&lt;/a&gt;). You get a clear separation of concerns, and the language nudges you toward good design by default.&lt;/p&gt;
&lt;p&gt;But my work isn’t limited to Elm. I frequently find myself building features that span both frontend and backend—writing new endpoints, and sometimes even designing new database tables. When I step outside the Elm world, I’m reminded that architecture is something I have to be intentional about again.&lt;/p&gt;</description></item><item><title>Starting Small with Elm: A Widget Approach</title><link>https://cekrem.github.io/posts/starting-small-with-elm-a-widget-approach/</link><pubDate>Tue, 03 Jun 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/starting-small-with-elm-a-widget-approach/</guid><description>&lt;p&gt;It&amp;rsquo;s awesome to learn Elm by building a side project, you absolutely should. And maybe you have – perhaps you&amp;rsquo;ve built a todo app, explored The Elm Architecture, and fallen in love with the reliability and maintainability that comes with functional programming and strong types.&lt;/p&gt;
&lt;p&gt;But come Monday morning, you&amp;rsquo;re back to wrestling with JavaScript bugs, runtime errors, and the nagging feeling that there has to be a better way. The problem isn&amp;rsquo;t that Elm isn&amp;rsquo;t ready for production work – it absolutely is. The problem is convincing your team, your boss, or your organization to take the leap. And when you&amp;rsquo;re thinking about wholesale replacement, your boss&amp;rsquo;s skepticism might be quite healthy. But here&amp;rsquo;s the thing: if you reduce the scope, you can also reduce the risk and buy-in required. Instead of &amp;ldquo;let&amp;rsquo;s rebuild our entire app in Elm,&amp;rdquo; what if the conversation was &amp;ldquo;let&amp;rsquo;s try Elm for this one small widget&amp;rdquo;? Suddenly, the stakes drop dramatically.&lt;/p&gt;</description></item><item><title>A Use Case for Port Boundaries in Frontend Development</title><link>https://cekrem.github.io/posts/a-case-for-port-boundaries-in-frontend/</link><pubDate>Mon, 19 May 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/a-case-for-port-boundaries-in-frontend/</guid><description>&lt;p&gt;In the Elm ecosystem, the browser is treated like an I/O device. DOM events, JavaScript interop, and even network requests are kept outside the core logic. Rather than allowing side effects to permeate the codebase, Elm channels them through strictly typed boundaries known as &lt;em&gt;ports&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This architectural stance is both radical and liberating. It allows you to build user interfaces where logic remains pure, testable, and robust, even as surrounding technologies evolve.&lt;/p&gt;</description></item><item><title>React Reconciliation: The Hidden Engine Behind Your Components</title><link>https://cekrem.github.io/posts/react-reconciliation-deep-dive/</link><pubDate>Tue, 08 Apr 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/react-reconciliation-deep-dive/</guid><description>&lt;h5 id="update-while-simplifying-a-complex-code-example-shortly-before-publishing-i-messed-up-some-details-thanks-to-reader-feedback-for-pointing-this-out-im-very-grateful-i-also-messed-up-an-internal-link-but-thats-fixed-as-well-thanks-again"&gt;
 Update: While simplifying a complex code example shortly before publishing, I messed up some details. Thanks to reader feedback for pointing this out, I&amp;rsquo;m very grateful! I also messed up an internal link, but that&amp;rsquo;s fixed as well. Thanks again
 &lt;a class="heading-link" href="#update-while-simplifying-a-complex-code-example-shortly-before-publishing-i-messed-up-some-details-thanks-to-reader-feedback-for-pointing-this-out-im-very-grateful-i-also-messed-up-an-internal-link-but-thats-fixed-as-well-thanks-again"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h5&gt;
&lt;h2 id="the-reconciliation-engine"&gt;
 The Reconciliation Engine
 &lt;a class="heading-link" href="#the-reconciliation-engine"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In my previous articles (&lt;a href="https://cekrem.github.io/posts/beyond-react-memo-smarter-performance-optimization/" &gt;1&lt;/a&gt;, &lt;a href="https://cekrem.github.io/posts/react-memo-when-it-helps-when-it-hurts/" &gt;2&lt;/a&gt;), I explored how &lt;code&gt;React.memo&lt;/code&gt; works and smarter ways to optimize performance through composition. But to truly master React performance, we need to understand the engine that powers it all: React&amp;rsquo;s reconciliation algorithm.&lt;/p&gt;</description></item><item><title>React.memo Demystified: When It Helps and When It Hurts</title><link>https://cekrem.github.io/posts/react-memo-when-it-helps-when-it-hurts/</link><pubDate>Wed, 02 Apr 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/react-memo-when-it-helps-when-it-hurts/</guid><description>&lt;h2 id="the-promise-of-memoization"&gt;
 The Promise of Memoization
 &lt;a class="heading-link" href="#the-promise-of-memoization"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;When React applications start to slow down, &lt;code&gt;React.memo&lt;/code&gt;, &lt;code&gt;useMemo&lt;/code&gt;, and &lt;code&gt;useCallback&lt;/code&gt; are often the first tools developers reach for. After all, preventing unnecessary re-renders seems like a straightforward path to better performance. But in the React ecosystem, memoization is far more complex than it first appears.&lt;/p&gt;
&lt;p&gt;In this post, we&amp;rsquo;ll look at how these tools actually work under the hood, the subtle ways they can fail, and when they&amp;rsquo;re truly beneficial versus when they&amp;rsquo;re just adding unnecessary complexity.&lt;/p&gt;</description></item><item><title>Building Better UI Components: Elm Ports with Web Components</title><link>https://cekrem.github.io/posts/elm-ports-with-web-components/</link><pubDate>Wed, 19 Mar 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/elm-ports-with-web-components/</guid><description>&lt;p&gt;One of the most common questions I get about Elm is: &amp;ldquo;How do I integrate it with existing JavaScript ecosystems?&amp;rdquo; While Elm&amp;rsquo;s isolation is a strength, real-world projects often require working with external libraries, APIs, or UI components. Doing incremental migration is also the recommended way to introduce Elm, and luckily there are may ways to accomplish this.&lt;/p&gt;
&lt;p&gt;Today, I&amp;rsquo;ll show you how to combine two powerful technologies:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Elm Ports&lt;/strong&gt;: The official way to communicate between Elm and JavaScript&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web Components&lt;/strong&gt;: Standard, framework-agnostic UI components&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This combination gives us the best of both worlds: Elm&amp;rsquo;s type safety and predictable architecture alongside the reusability and interoperability of Web Components. Let&amp;rsquo;s dive in!&lt;/p&gt;</description></item><item><title>Beyond React.memo: Smarter Ways to Optimize Performance</title><link>https://cekrem.github.io/posts/beyond-react-memo-smarter-performance-optimization/</link><pubDate>Tue, 11 Mar 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/beyond-react-memo-smarter-performance-optimization/</guid><description>&lt;h2 id="introduction"&gt;
 Introduction
 &lt;a class="heading-link" href="#introduction"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;When it comes to React performance optimization, &lt;code&gt;React.memo&lt;/code&gt; is often the first tool developers reach for. It&amp;rsquo;s the hammer we grab when we notice re-render issues, and suddenly everything looks like a nail. But what if I told you that in many cases, there are simpler, more elegant solutions that align better with React&amp;rsquo;s compositional nature?&lt;/p&gt;
&lt;p&gt;Today, I want to explore some fundamental concepts about how React renders components and share composition patterns that can dramatically improve performance without the complexity and gotchas of memoization.&lt;/p&gt;</description></item><item><title>Why I Hope I Get to Write a Lot of Elm Code in 2025</title><link>https://cekrem.github.io/posts/why-i-hope-i-get-to-write-a-lot-of-elm-code-in-2025/</link><pubDate>Tue, 04 Mar 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/why-i-hope-i-get-to-write-a-lot-of-elm-code-in-2025/</guid><description>&lt;p&gt;In a world dominated by React, Vue, and Svelte, it might seem strange to highlight Elm – a niche language that has existed since 2012 but has had fewer releases since then than React has in a year. But right now, when frontend development is becoming increasingly complex, and clients are doing heavy lifting that previously belonged on the other side of an API call, it&amp;rsquo;s worth taking a closer look at what Elm does right.&lt;/p&gt;</description></item><item><title>Single Responsibility Principle in React: The Art of Component Focus</title><link>https://cekrem.github.io/posts/single-responsibility-principle-in-react/</link><pubDate>Tue, 04 Feb 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/single-responsibility-principle-in-react/</guid><description>&lt;h2 id="introduction"&gt;
 Introduction
 &lt;a class="heading-link" href="#introduction"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;We&amp;rsquo;ve covered &lt;a href="https://cekrem.github.io/posts/clean-architecture-and-plugins-in-go" &gt;Dependency Inversion&lt;/a&gt;, &lt;a href="https://cekrem.github.io/posts/interface-segregation-in-practice" &gt;Interface Segregation&lt;/a&gt;, &lt;a href="https://cekrem.github.io/posts/liskov-substitution-the-real-meaning-of-inheritance" &gt;Liskov Substitution&lt;/a&gt;, and &lt;a href="https://cekrem.github.io/posts/open-closed-principle-in-react" &gt;Open-Closed&lt;/a&gt;. Now it&amp;rsquo;s time for the foundation of SOLID: the Single Responsibility Principle (SRP).&lt;/p&gt;
&lt;p&gt;Again, kudos to Uncle Bob for reminding me about the importance of good &lt;strong&gt;software architecture&lt;/strong&gt; in his classic &lt;a href="https://amzn.to/4iAc8o1" class="external-link" target="_blank" rel="noopener"&gt;Clean Architecture&lt;/a&gt;! That book is my primary inspiration for this series.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Single Responsibility Principle states that a class should have only one reason to change.&lt;/p&gt;</description></item><item><title>A Use Case for `UseCase`s in Kotlin</title><link>https://cekrem.github.io/posts/a-use-case-for-usecases-in-kotlin/</link><pubDate>Fri, 31 Jan 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/a-use-case-for-usecases-in-kotlin/</guid><description>&lt;h2 id="my-first-encounter-with-a-kotlin-usecase"&gt;
 My First Encounter with a Kotlin &lt;code&gt;UseCase&lt;/code&gt;
 &lt;a class="heading-link" href="#my-first-encounter-with-a-kotlin-usecase"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;One of my responsibilities as an Android Developer in Vipps (Mobilepay) was to do tech interviews. After a while, I also made the tech assignments and changed the recruitment process a bit. But in the earlier days, we used a standard &amp;ldquo;build X using Y&amp;rdquo;, where &amp;ldquo;Y&amp;rdquo; was modern Android tools (preferably Compose), and &amp;ldquo;X&amp;rdquo; was some non-descript hello world-ish app that did something I can&amp;rsquo;t for the life of me remember. During one of the tech task evaluations we did prior to an interview, I encountered a strange animal completely unknown to me. A &lt;code&gt;UseCase&lt;/code&gt; class, with an &lt;code&gt;operator fun invoke()&lt;/code&gt; method.&lt;/p&gt;</description></item><item><title>Open-Closed Principle in React: Building Extensible Components</title><link>https://cekrem.github.io/posts/open-closed-principle-in-react/</link><pubDate>Tue, 28 Jan 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/open-closed-principle-in-react/</guid><description>&lt;h2 id="introduction"&gt;
 Introduction
 &lt;a class="heading-link" href="#introduction"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;After exploring &lt;a href="https://cekrem.github.io/posts/clean-architecture-and-plugins-in-go" &gt;Dependency Inversion&lt;/a&gt;, &lt;a href="https://cekrem.github.io/posts/interface-segregation-in-practice" &gt;Interface Segregation&lt;/a&gt;, and &lt;a href="https://cekrem.github.io/posts/liskov-substitution-the-real-meaning-of-inheritance" &gt;Liskov Substitution&lt;/a&gt;, let&amp;rsquo;s tackle the Open-Closed Principle (OCP) in the context of modern React applications.&lt;/p&gt;
&lt;p&gt;Again, kudos to Uncle Bob for reminding me about the importance of good &lt;strong&gt;software architecture&lt;/strong&gt; in his classic &lt;a href="https://amzn.to/4iAc8o1" class="external-link" target="_blank" rel="noopener"&gt;Clean Architecture&lt;/a&gt;! That book is my primary inspiration for this series.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Open-Closed Principle states that software entities should be open for extension but closed for modification.&lt;/p&gt;</description></item><item><title>Liskov Substitution: The Real Meaning of Inheritance</title><link>https://cekrem.github.io/posts/liskov-substitution-the-real-meaning-of-inheritance/</link><pubDate>Tue, 21 Jan 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/liskov-substitution-the-real-meaning-of-inheritance/</guid><description>&lt;h2 id="introduction"&gt;
 Introduction
 &lt;a class="heading-link" href="#introduction"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;After exploring &lt;a href="https://cekrem.github.io/posts/clean-architecture-and-plugins-in-go" &gt;Dependency Inversion&lt;/a&gt; and &lt;a href="https://cekrem.github.io/posts/interface-segregation-in-practice" &gt;Interface Segregation&lt;/a&gt;, let&amp;rsquo;s tackle perhaps the most misunderstood principle of SOLID: The Liskov Substitution Principle (LSP).&lt;/p&gt;
&lt;p&gt;Again, kudos to Uncle Bob for reminding me about the importance of good &lt;strong&gt;software architecture&lt;/strong&gt; in his classic &lt;a href="https://amzn.to/4iAc8o1" class="external-link" target="_blank" rel="noopener"&gt;Clean Architecture&lt;/a&gt;! That book is my primary inspiration for this series. Without clean architecture, we&amp;rsquo;ll all be building firmware (my paraphrased summary).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Liskov Substitution Principle states that if S is a subtype of T, then objects of type T may be replaced with objects of type S without altering any of the desirable properties of the program.&lt;/p&gt;</description></item><item><title>Interface Segregation: Why Your Interfaces Should Be Small and Focused</title><link>https://cekrem.github.io/posts/interface-segregation-in-practice/</link><pubDate>Tue, 14 Jan 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/interface-segregation-in-practice/</guid><description>&lt;h2 id="introduction"&gt;
 Introduction
 &lt;a class="heading-link" href="#introduction"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In our &lt;a href="https://cekrem.github.io/posts/clean-architecture-and-plugins-in-go" &gt;previous post&lt;/a&gt;, we explored the Dependency Inversion Principle and how it enables clean, modular architectures. Today, let&amp;rsquo;s dive into another crucial SOLID principle: Interface Segregation.&lt;/p&gt;
&lt;p&gt;Again, kudos to Uncle Bob for reminding me about the importance of good &lt;strong&gt;software architecture&lt;/strong&gt; in his classic &lt;a href="https://amzn.to/4iAc8o1" class="external-link" target="_blank" rel="noopener"&gt;Clean Architecture&lt;/a&gt;! That book is my primary inspiration for this series. Without clean architecture, we&amp;rsquo;ll all be building firmware (my paraphrased summary).&lt;/p&gt;</description></item><item><title>Clean Architecture: A Practical Example of Dependency Inversion in Go using Plugins</title><link>https://cekrem.github.io/posts/clean-architecture-and-plugins-in-go/</link><pubDate>Tue, 07 Jan 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/clean-architecture-and-plugins-in-go/</guid><description>&lt;h2 id="introduction"&gt;
 Introduction
 &lt;a class="heading-link" href="#introduction"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Update: this has become a series, the next entry can be found here: &lt;a href="https://cekrem.github.io/posts/interface-segregation-in-practice/" &gt;Interface Segregation: Why Your Interfaces Should Be Small and Focused&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ve lately enjoyed revisiting the &lt;a href="//en.wikipedia.org/wiki/SOLID" class="external-link" target="_blank" rel="noopener"&gt;SOLID Design Principles&lt;/a&gt;. In the world of software architecture, few principles have stood the test of time like these. I find the &amp;ldquo;Dependency Inversion Principle&amp;rdquo; particularly interesting, as it&amp;rsquo;s one of the few that are either forgotten in modern applications, or drowned in so much over-engineering that the cost/benefit equation is offset anyways.&lt;/p&gt;</description></item><item><title>Books I Think Software Engineers Should Read</title><link>https://cekrem.github.io/posts/books-i-think-software-engineers-should-read/</link><pubDate>Wed, 18 Dec 2024 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/books-i-think-software-engineers-should-read/</guid><description>&lt;p&gt;What follows is a non-ordered &amp;amp; non-exhaustive list of great programming books that I&amp;rsquo;d recommend every ambitious software engineer. The language specific ones are obviously not for everyone.&lt;/p&gt;
&lt;p&gt;Disclaimer: I have not read all of these from cover to cover. I&amp;rsquo;ve read most, but some are on my list of books to read next based on suggestions and/or reviews from people I trust.&lt;/p&gt;
&lt;h2 id="general"&gt;
 General
 &lt;a class="heading-link" href="#general"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://amzn.to/4gAOaHa" class="external-link" target="_blank" rel="noopener"&gt;Deep Work: Rules for Focused Success in a Distracted World&lt;/a&gt; – Not a programming / software engineering book at all per say, but a &lt;em&gt;highly&lt;/em&gt; recommended read regardless. If you read one book on this list, go for this one, for real.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/3VIleoE" class="external-link" target="_blank" rel="noopener"&gt;Clean Code&lt;/a&gt;, &lt;a href="https://amzn.to/3ZZu3Ny" class="external-link" target="_blank" rel="noopener"&gt;Clean Code&lt;em&gt;r&lt;/em&gt;&lt;/a&gt; and &lt;a href="https://amzn.to/4iAc8o1" class="external-link" target="_blank" rel="noopener"&gt;Clean Architecture&lt;/a&gt; — These Uncle Bob classics are great. I&amp;rsquo;m currently enjoying the architecture one &lt;em&gt;on audible&lt;/em&gt;, that&amp;rsquo;s a first for me with a software engineering book. Simply great, and truly a pleasant read/listen.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/4gjf4Ud" class="external-link" target="_blank" rel="noopener"&gt;The Pragmatic Programmer: Your Journey To Mastery&lt;/a&gt; — A classic, and a good one at that!&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/41GYOrQ" class="external-link" target="_blank" rel="noopener"&gt;Staff Engineer: Leadership beyond the management track&lt;/a&gt; — This one I find a tiny bit boring, to be perfectly honest, but still very helpful. Lot&amp;rsquo;s of insight about &amp;ldquo;all the other stuff&amp;rdquo; (not coding).&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/4gjc9ex" class="external-link" target="_blank" rel="noopener"&gt;The Effective Engineer: How to Leverage Your Efforts In Software Engineering to Make a Disproportionate and Meaningful Impact&lt;/a&gt; — I haven&amp;rsquo;t read this one yet, but it&amp;rsquo;s been highly recommended to me by trustworthy people. And how about that killer subtitle, ey?&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/4lfGwVD" class="external-link" target="_blank" rel="noopener"&gt;A Common-Sense Guide to Data Structures and Algorithms, Second Edition&lt;/a&gt; — A practical approach to understanding data structures and algorithms that focuses on real-world applications rather than academic theory.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/44B0dQE" class="external-link" target="_blank" rel="noopener"&gt;Domain Modeling Made Functional: Tackle Software Complexity with Domain-Driven Design and F#&lt;/a&gt; — Excellent introduction to domain-driven design principles using functional programming concepts, applicable beyond F# to any language.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="elm"&gt;
 Elm
 &lt;a class="heading-link" href="#elm"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://amzn.to/4kBLTxA" class="external-link" target="_blank" rel="noopener"&gt;Elm in Action&lt;/a&gt; – This is The Book™ on Elm, by Richard Feldman (author of &lt;a href="https://www.roc-lang.org" class="external-link" target="_blank" rel="noopener"&gt;the Roc Programming language&lt;/a&gt;). It&amp;rsquo;s simply great. The last few chapters are a tiny bit overwhelming if you&amp;rsquo;re new to Elm, but thankfully &lt;a href="https://elm.land" class="external-link" target="_blank" rel="noopener"&gt;Elm Land&lt;/a&gt; solves much of that stuff for you.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://elm-lang.org/community" class="external-link" target="_blank" rel="noopener"&gt;The Elm Community&lt;/a&gt; –Not a book at all, I know, but since this is my all time favorite programming community I can&amp;rsquo;t help but mention it anyways. The Slack, the Discourse, Subreddit – it&amp;rsquo;s all great.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="golang"&gt;
 Golang
 &lt;a class="heading-link" href="#golang"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://amzn.to/4fruZyJ" class="external-link" target="_blank" rel="noopener"&gt;The Go Programming Language&lt;/a&gt; —
Kind of obvious, this one. But a great classic! I remember enjoying the chapter about UTF-8 a lot, as well as the generally thorough explanations of how and &lt;em&gt;why&lt;/em&gt; Golang behaves.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/3Bpf4TL" class="external-link" target="_blank" rel="noopener"&gt;Concurrency in Go: Tools and Techniques for Developers&lt;/a&gt; — This is a truly great programming book! Even though Golang is made for concurrency, it&amp;rsquo;s still very possible to mess up. This book shows you how it&amp;rsquo;s done. What&amp;rsquo;s a bit cool (🤓) is that it predates the &lt;code&gt;context.Context&lt;/code&gt; interface, and as such suggests using a manual &amp;ldquo;done channel&amp;rdquo; to enable canceling of coroutines. It shows the author&amp;rsquo;s insight that an exact pattern like that was introduced with the &lt;code&gt;Context.Done()&lt;/code&gt; method introduced later in the language. For more on that, check out &lt;a href="https://github.com/cekrem/goutils/commit/0a511038efd9186cf204d503f7ff37c83b5c5838" class="external-link" target="_blank" rel="noopener"&gt;this git diff&lt;/a&gt;, on a small golang utility library I started on way back.&lt;/li&gt;
&lt;li&gt;Feel free to skip this one, though: &lt;a href="https://amzn.to/3P1uq3R" class="external-link" target="_blank" rel="noopener"&gt;Learning Functional Programming in Go&lt;/a&gt; — This book should, IMHO, rather have been a tweet. Something like this: &amp;ldquo;Go is not really suited for functional programming, I&amp;rsquo;d advice you not to do it at scale.&amp;rdquo; Fun fact: this book is actually what got me into &lt;a href="#kotlin" &gt;Kotlin&lt;/a&gt;. All that talk about &lt;a href="https://stackoverflow.com/questions/310974/what-is-tail-call-optimization" class="external-link" target="_blank" rel="noopener"&gt;tail call optimization&lt;/a&gt; (and how Golang is &lt;em&gt;not&lt;/em&gt; doing that&amp;hellip;) got me searching for more functional fun outside of Elm, Haskell and Lisp.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="python"&gt;
 Python
 &lt;a class="heading-link" href="#python"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://amzn.to/3Dyiyni" class="external-link" target="_blank" rel="noopener"&gt;Fluent Python: Clear, Concise, and Effective Programming&lt;/a&gt; — I read this one on my Kindle, actually, before I learned that Kindle&amp;rsquo;s not where programming books really shine. That aside, I have nothing but fond memories from the first edition, and I&amp;rsquo;ve heard the updates on the second edition are really worthwhile. If you want to read &lt;em&gt;one&lt;/em&gt; Python book, this is it.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/4gx5tt2" class="external-link" target="_blank" rel="noopener"&gt;Automate the Boring Stuff with Python, 2nd Edition: Practical Programming for Total Beginners&lt;/a&gt; — This one is also cool! While mainly targeting &amp;ldquo;total beginners&amp;rdquo;, it&amp;rsquo;s also suitable for seasoned programmers who don&amp;rsquo;t usually work in Python, but want to leverage its super fast scripting capabilities to automate stuff.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="kotlin"&gt;
 Kotlin
 &lt;a class="heading-link" href="#kotlin"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://amzn.to/4gjT1wU" class="external-link" target="_blank" rel="noopener"&gt;Functional Programming in Kotlin&lt;/a&gt; — Functional Programming &lt;em&gt;and&lt;/em&gt; Kotlin in the same book title?! No-brainer. This one is great!&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/402VYev" class="external-link" target="_blank" rel="noopener"&gt;Kotlin in Action&lt;/a&gt; — One of two &amp;ldquo;general Kotlin books&amp;rdquo; I&amp;rsquo;d recommend.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/3ZYEdxN" class="external-link" target="_blank" rel="noopener"&gt;Mastering Kotlin&lt;/a&gt; — The other one :)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="lisp"&gt;
 Lisp
 &lt;a class="heading-link" href="#lisp"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://amzn.to/4izuO7c" class="external-link" target="_blank" rel="noopener"&gt;Land of Lisp: Learn to Program in Lisp, One Game at a Time!&lt;/a&gt; — A bit whimsical, but then again Lisp is &lt;em&gt;not&lt;/em&gt;, so in sum a semi-serious book. I liked it ¯\&lt;em&gt;(ツ)&lt;/em&gt;/¯&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/4gf8sq2" class="external-link" target="_blank" rel="noopener"&gt;On Lisp: Advanced Techniques for Common Lisp&lt;/a&gt; — &lt;em&gt;The&lt;/em&gt; Lisp book, by mr. Paul Graham himself. Hats off, hands down.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/3ZVWUSW" class="external-link" target="_blank" rel="noopener"&gt;Practical Common Lisp&lt;/a&gt; — The other Lisp book, I guess? Great.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="react"&gt;
 React
 &lt;a class="heading-link" href="#react"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://amzn.to/4iFXVWq" class="external-link" target="_blank" rel="noopener"&gt;Advanced React: Deep dives, investigations, performance patterns and techniques&lt;/a&gt; — I&amp;rsquo;ve actually read (or at least skimmed) quite a few books on React — I even started writing one, way back — but this is the only one I think is worth recommending. If you&amp;rsquo;re a complete beginner there are probably other/better options, but given that you&amp;rsquo;re at least semi-familiar with thinking in React, this is The One.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="rust"&gt;
 Rust
 &lt;a class="heading-link" href="#rust"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://amzn.to/4gFp7D3" class="external-link" target="_blank" rel="noopener"&gt;The Rust Programming Language&lt;/a&gt; — &amp;ldquo;The Book&amp;rdquo;, as official as it gets, and quite good at that.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/400rtXM" class="external-link" target="_blank" rel="noopener"&gt;Programming Rust&lt;/a&gt; — Less official, but a fine resource regardless. The two complement each other (and of course overlap a bit as well).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Warning: I might add more later.&lt;/p&gt;</description></item></channel></rss>