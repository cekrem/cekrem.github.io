<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Clean Architecture on cekrem.github.io</title><link>https://cekrem.github.io/tags/clean-architecture/</link><description>Recent content in Clean Architecture on cekrem.github.io</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 18 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://cekrem.github.io/tags/clean-architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Making Impossible States Impossible: Type-Safe Domain Modeling with Functional Dependency Injection</title><link>https://cekrem.github.io/posts/making-impossible-states-impossible-with-functional-dependency-injection/</link><pubDate>Mon, 18 Aug 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/making-impossible-states-impossible-with-functional-dependency-injection/</guid><description>&lt;p>Most applications don&amp;rsquo;t fail because algorithms are hard—they fail because our models allow states that make no sense in the domain. &amp;ldquo;User without email but verified&amp;rdquo;, &amp;ldquo;order that&amp;rsquo;s both shipped and cancelled&amp;rdquo;, &amp;ldquo;sum &amp;lt; 0&amp;rdquo;, &amp;ldquo;modal dialog both closed and active&amp;rdquo;. These states should be impossible from the start.&lt;/p>
&lt;blockquote>
&lt;p>Among the most time-consuming bugs to track down are the ones where we look at our application state and say &amp;ldquo;this shouldn&amp;rsquo;t be possible.&amp;rdquo;&lt;/p></description></item><item><title>A Use Case for Port Boundaries in Frontend Development</title><link>https://cekrem.github.io/posts/a-case-for-port-boundaries-in-frontend/</link><pubDate>Mon, 19 May 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/a-case-for-port-boundaries-in-frontend/</guid><description>&lt;p>In the Elm ecosystem, the browser is treated like an I/O device. DOM events, JavaScript interop, and even network requests are kept outside the core logic. Rather than allowing side effects to permeate the codebase, Elm channels them through strictly typed boundaries known as &lt;em>ports&lt;/em>.&lt;/p>
&lt;p>This architectural stance is both radical and liberating. It allows you to build user interfaces where logic remains pure, testable, and robust, even as surrounding technologies evolve.&lt;/p></description></item><item><title>Dependency Inversion in React: Building Truly Testable Components</title><link>https://cekrem.github.io/posts/dependency-inversion-in-react/</link><pubDate>Fri, 09 May 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/dependency-inversion-in-react/</guid><description>&lt;p>In the world of React development, we often find ourselves writing components that are tightly coupled to their dependencies. This makes testing difficult, maintenance a challenge, and change nearly impossible. The Dependency Inversion Principle (DIP) offers a way out of this mess, but how do we apply it effectively &lt;strong>in React&lt;/strong>?&lt;/p>
&lt;p>&lt;strong>Note:&lt;/strong> For a more backend-oriented take on Dependency Inversion, check out my previous post on &lt;a href="https://cekrem.github.io/posts/clean-architecture-and-plugins-in-go/" class="external-link" target="_blank" rel="noopener">Dependency Inversion in Go Using Plugins&lt;/a>.&lt;/p></description></item><item><title>Coding as Craft: Going Back to the Old Gym</title><link>https://cekrem.github.io/posts/coding-as-craft-going-back-to-the-old-gym/</link><pubDate>Tue, 22 Apr 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/coding-as-craft-going-back-to-the-old-gym/</guid><description>&lt;p>Recently, &lt;a href="https://x.com/tobi/status/1909231499448401946" class="external-link" target="_blank" rel="noopener">Shopify&amp;rsquo;s CEO Tobi Lütke shared his thoughts on AI&amp;rsquo;s role in coding&lt;/a>, stating that &amp;ldquo;reflexive AI usage is now a baseline expectation at Shopify.&amp;rdquo; The gist of his message was that AI is revolutionizing how we work, and everybody should jump on board this train or risk being left behind. I&amp;rsquo;m paraphrasing a bit, but not much – check out the post for complete context and content.&lt;/p>
&lt;p>This struck a chord with me, but not in the way he intended. In a Slack conversation with fellow Elm engineers, I found myself typing:&lt;/p></description></item><item><title>React Reconciliation: The Hidden Engine Behind Your Components</title><link>https://cekrem.github.io/posts/react-reconciliation-deep-dive/</link><pubDate>Tue, 08 Apr 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/react-reconciliation-deep-dive/</guid><description>&lt;h5 id="update-while-simplifying-a-complex-code-example-shortly-before-publishing-i-messed-up-some-details-thanks-to-reader-feedback-for-pointing-this-out-im-very-grateful-i-also-messed-up-an-internal-link-but-thats-fixed-as-well-thanks-again">
 Update: While simplifying a complex code example shortly before publishing, I messed up some details. Thanks to reader feedback for pointing this out, I&amp;rsquo;m very grateful! I also messed up an internal link, but that&amp;rsquo;s fixed as well. Thanks again
 &lt;a class="heading-link" href="#update-while-simplifying-a-complex-code-example-shortly-before-publishing-i-messed-up-some-details-thanks-to-reader-feedback-for-pointing-this-out-im-very-grateful-i-also-messed-up-an-internal-link-but-thats-fixed-as-well-thanks-again">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h5>
&lt;h2 id="the-reconciliation-engine">
 The Reconciliation Engine
 &lt;a class="heading-link" href="#the-reconciliation-engine">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>In my previous articles (&lt;a href="https://cekrem.github.io/posts/beyond-react-memo-smarter-performance-optimization/" >1&lt;/a>, &lt;a href="https://cekrem.github.io/posts/react-memo-when-it-helps-when-it-hurts/" >2&lt;/a>), I explored how &lt;code>React.memo&lt;/code> works and smarter ways to optimize performance through composition. But to truly master React performance, we need to understand the engine that powers it all: React&amp;rsquo;s reconciliation algorithm.&lt;/p></description></item><item><title>React.memo Demystified: When It Helps and When It Hurts</title><link>https://cekrem.github.io/posts/react-memo-when-it-helps-when-it-hurts/</link><pubDate>Wed, 02 Apr 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/react-memo-when-it-helps-when-it-hurts/</guid><description>&lt;h2 id="the-promise-of-memoization">
 The Promise of Memoization
 &lt;a class="heading-link" href="#the-promise-of-memoization">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>When React applications start to slow down, &lt;code>React.memo&lt;/code>, &lt;code>useMemo&lt;/code>, and &lt;code>useCallback&lt;/code> are often the first tools developers reach for. After all, preventing unnecessary re-renders seems like a straightforward path to better performance. But in the React ecosystem, memoization is far more complex than it first appears.&lt;/p>
&lt;p>In this post, we&amp;rsquo;ll look at how these tools actually work under the hood, the subtle ways they can fail, and when they&amp;rsquo;re truly beneficial versus when they&amp;rsquo;re just adding unnecessary complexity.&lt;/p></description></item><item><title>Beyond React.memo: Smarter Ways to Optimize Performance</title><link>https://cekrem.github.io/posts/beyond-react-memo-smarter-performance-optimization/</link><pubDate>Tue, 11 Mar 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/beyond-react-memo-smarter-performance-optimization/</guid><description>&lt;h2 id="introduction">
 Introduction
 &lt;a class="heading-link" href="#introduction">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>When it comes to React performance optimization, &lt;code>React.memo&lt;/code> is often the first tool developers reach for. It&amp;rsquo;s the hammer we grab when we notice re-render issues, and suddenly everything looks like a nail. But what if I told you that in many cases, there are simpler, more elegant solutions that align better with React&amp;rsquo;s compositional nature?&lt;/p>
&lt;p>Today, I want to explore some fundamental concepts about how React renders components and share composition patterns that can dramatically improve performance without the complexity and gotchas of memoization.&lt;/p></description></item><item><title>Why I Hope I Get to Write a Lot of Elm Code in 2025</title><link>https://cekrem.github.io/posts/why-i-hope-i-get-to-write-a-lot-of-elm-code-in-2025/</link><pubDate>Tue, 04 Mar 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/why-i-hope-i-get-to-write-a-lot-of-elm-code-in-2025/</guid><description>&lt;p>In a world dominated by React, Vue, and Svelte, it might seem strange to highlight Elm – a niche language that has existed since 2012 but has had fewer releases since then than React has in a year. But right now, when frontend development is becoming increasingly complex, and clients are doing heavy lifting that previously belonged on the other side of an API call, it&amp;rsquo;s worth taking a closer look at what Elm does right.&lt;/p></description></item><item><title>Refactoring Towards Cleaner Boundaries: Lessons from Building a Markdown Blog Engine (Part 3)</title><link>https://cekrem.github.io/posts/refactoring-towards-cleaner-boundaries/</link><pubDate>Tue, 25 Feb 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/refactoring-towards-cleaner-boundaries/</guid><description>&lt;p>In &lt;a href="https://cekrem.github.io/posts/replacing-hugo-with-kotlin-clean-architecture" >part 1&lt;/a>, we laid out our Clean Architecture vision. In &lt;a href="https://cekrem.github.io/posts/double-loop-tdd-blog-engine-pt2" >part 2&lt;/a>, we explored Double Loop TDD. Today, we dive into the &lt;strong>refactoring journey&lt;/strong> that emerged from implementing these principles.&lt;/p>
&lt;p>The source code at the time of writing is &lt;a href="https://github.com/cekrem/clean-blog/tree/v0.3" class="external-link" target="_blank" rel="noopener">available on GitHub&lt;/a>.&lt;/p>
&lt;h2 id="the-controller-conundrum">
 The Controller Conundrum
 &lt;a class="heading-link" href="#the-controller-conundrum">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>One of the most significant architectural changes in this iteration was moving the &lt;code>ContentController&lt;/code> from the infrastructure layer to the &lt;strong>interface adapters layer&lt;/strong>. This shift better aligns with Clean Architecture principles:&lt;/p></description></item><item><title>Double Loop TDD: Building My Blog Engine the Right Way (part 2)</title><link>https://cekrem.github.io/posts/double-loop-tdd-blog-engine-pt2/</link><pubDate>Tue, 18 Feb 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/double-loop-tdd-blog-engine-pt2/</guid><description>&lt;h2 id="from-hugo-to-kotlin-the-journey-continues">
 From Hugo to Kotlin: The Journey Continues
 &lt;a class="heading-link" href="#from-hugo-to-kotlin-the-journey-continues">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>In my &lt;a href="https://cekrem.github.io/posts/replacing-hugo-with-kotlin-clean-architecture" >previous post&lt;/a>, embarked on a bold and ambitious journey to replace Hugo with a custom Kotlin-based blog engine built using Clean Architecture principles (to the letter!). Today, I want to dive deeper into the development process, specifically how I&amp;rsquo;m using &lt;strong>Double Loop TDD&lt;/strong> to ensure the quality and maintainability of the system. Again, I&amp;rsquo;m trying to go all-in, basically to see how far is too far, and to learn and explore.&lt;/p></description></item><item><title>Making a Clean Architecture Blog Engine From Scratch pt 1</title><link>https://cekrem.github.io/posts/replacing-hugo-with-kotlin-clean-architecture/</link><pubDate>Tue, 11 Feb 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/replacing-hugo-with-kotlin-clean-architecture/</guid><description>&lt;h2 id="lets-make-a-blog-engine-ey">
 Let&amp;rsquo;s make a blog engine, ey?
 &lt;a class="heading-link" href="#lets-make-a-blog-engine-ey">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>Don&amp;rsquo;t get me wrong - &lt;a href="https://gohugo.io/" class="external-link" target="_blank" rel="noopener">Hugo&lt;/a> (the stuff that I&amp;rsquo;m currently using to drive this site) is great. It&amp;rsquo;s blazing fast, feature-rich, and battle-tested. But as a developer who&amp;rsquo;s been diving deep into Clean Architecture lately (as you might have noticed from my &lt;a href="https://cekrem.github.io/posts/clean-architecture-and-plugins-in-go" >recent&lt;/a> &lt;a href="https://cekrem.github.io/posts/interface-segregation-in-practice" >posts&lt;/a>), I&amp;rsquo;ve been itching to apply these principles to a real project. And what better way to learn than by potentially over-engineering my own blog engine?&lt;/p></description></item><item><title>Single Responsibility Principle in React: The Art of Component Focus</title><link>https://cekrem.github.io/posts/single-responsibility-principle-in-react/</link><pubDate>Tue, 04 Feb 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/single-responsibility-principle-in-react/</guid><description>&lt;h2 id="introduction">
 Introduction
 &lt;a class="heading-link" href="#introduction">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>We&amp;rsquo;ve covered &lt;a href="https://cekrem.github.io/posts/clean-architecture-and-plugins-in-go" >Dependency Inversion&lt;/a>, &lt;a href="https://cekrem.github.io/posts/interface-segregation-in-practice" >Interface Segregation&lt;/a>, &lt;a href="https://cekrem.github.io/posts/liskov-substitution-the-real-meaning-of-inheritance" >Liskov Substitution&lt;/a>, and &lt;a href="https://cekrem.github.io/posts/open-closed-principle-in-react" >Open-Closed&lt;/a>. Now it&amp;rsquo;s time for the foundation of SOLID: the Single Responsibility Principle (SRP).&lt;/p>
&lt;p>Again, kudos to Uncle Bob for reminding me about the importance of good &lt;strong>software architecture&lt;/strong> in his classic &lt;a href="https://amzn.to/4iAc8o1" class="external-link" target="_blank" rel="noopener">Clean Architecture&lt;/a>! That book is my primary inspiration for this series.&lt;/p>
&lt;blockquote>
&lt;p>The Single Responsibility Principle states that a class should have only one reason to change.&lt;/p></description></item><item><title>A Use Case for `UseCase`s in Kotlin</title><link>https://cekrem.github.io/posts/a-use-case-for-usecases-in-kotlin/</link><pubDate>Fri, 31 Jan 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/a-use-case-for-usecases-in-kotlin/</guid><description>&lt;h2 id="my-first-encounter-with-a-kotlin-usecase">
 My First Encounter with a Kotlin &lt;code>UseCase&lt;/code>
 &lt;a class="heading-link" href="#my-first-encounter-with-a-kotlin-usecase">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>One of my responsibilities as an Android Developer in Vipps (Mobilepay) was to do tech interviews. After a while, I also made the tech assignments and changed the recruitment process a bit. But in the earlier days, we used a standard &amp;ldquo;build X using Y&amp;rdquo;, where &amp;ldquo;Y&amp;rdquo; was modern Android tools (preferably Compose), and &amp;ldquo;X&amp;rdquo; was some non-descript hello world-ish app that did something I can&amp;rsquo;t for the life of me remember. During one of the tech task evaluations we did prior to an interview, I encountered a strange animal completely unknown to me. A &lt;code>UseCase&lt;/code> class, with an &lt;code>operator fun invoke()&lt;/code> method.&lt;/p></description></item><item><title>Open-Closed Principle in React: Building Extensible Components</title><link>https://cekrem.github.io/posts/open-closed-principle-in-react/</link><pubDate>Tue, 28 Jan 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/open-closed-principle-in-react/</guid><description>&lt;h2 id="introduction">
 Introduction
 &lt;a class="heading-link" href="#introduction">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>After exploring &lt;a href="https://cekrem.github.io/posts/clean-architecture-and-plugins-in-go" >Dependency Inversion&lt;/a>, &lt;a href="https://cekrem.github.io/posts/interface-segregation-in-practice" >Interface Segregation&lt;/a>, and &lt;a href="https://cekrem.github.io/posts/liskov-substitution-the-real-meaning-of-inheritance" >Liskov Substitution&lt;/a>, let&amp;rsquo;s tackle the Open-Closed Principle (OCP) in the context of modern React applications.&lt;/p>
&lt;p>Again, kudos to Uncle Bob for reminding me about the importance of good &lt;strong>software architecture&lt;/strong> in his classic &lt;a href="https://amzn.to/4iAc8o1" class="external-link" target="_blank" rel="noopener">Clean Architecture&lt;/a>! That book is my primary inspiration for this series.&lt;/p>
&lt;blockquote>
&lt;p>The Open-Closed Principle states that software entities should be open for extension but closed for modification.&lt;/p></description></item><item><title>Liskov Substitution: The Real Meaning of Inheritance</title><link>https://cekrem.github.io/posts/liskov-substitution-the-real-meaning-of-inheritance/</link><pubDate>Tue, 21 Jan 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/liskov-substitution-the-real-meaning-of-inheritance/</guid><description>&lt;h2 id="introduction">
 Introduction
 &lt;a class="heading-link" href="#introduction">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>After exploring &lt;a href="https://cekrem.github.io/posts/clean-architecture-and-plugins-in-go" >Dependency Inversion&lt;/a> and &lt;a href="https://cekrem.github.io/posts/interface-segregation-in-practice" >Interface Segregation&lt;/a>, let&amp;rsquo;s tackle perhaps the most misunderstood principle of SOLID: The Liskov Substitution Principle (LSP).&lt;/p>
&lt;p>Again, kudos to Uncle Bob for reminding me about the importance of good &lt;strong>software architecture&lt;/strong> in his classic &lt;a href="https://amzn.to/4iAc8o1" class="external-link" target="_blank" rel="noopener">Clean Architecture&lt;/a>! That book is my primary inspiration for this series. Without clean architecture, we&amp;rsquo;ll all be building firmware (my paraphrased summary).&lt;/p>
&lt;blockquote>
&lt;p>The Liskov Substitution Principle states that if S is a subtype of T, then objects of type T may be replaced with objects of type S without altering any of the desirable properties of the program.&lt;/p></description></item><item><title>Interface Segregation: Why Your Interfaces Should Be Small and Focused</title><link>https://cekrem.github.io/posts/interface-segregation-in-practice/</link><pubDate>Tue, 14 Jan 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/interface-segregation-in-practice/</guid><description>&lt;h2 id="introduction">
 Introduction
 &lt;a class="heading-link" href="#introduction">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>In our &lt;a href="https://cekrem.github.io/posts/clean-architecture-and-plugins-in-go" >previous post&lt;/a>, we explored the Dependency Inversion Principle and how it enables clean, modular architectures. Today, let&amp;rsquo;s dive into another crucial SOLID principle: Interface Segregation.&lt;/p>
&lt;p>Again, kudos to Uncle Bob for reminding me about the importance of good &lt;strong>software architecture&lt;/strong> in his classic &lt;a href="https://amzn.to/4iAc8o1" class="external-link" target="_blank" rel="noopener">Clean Architecture&lt;/a>! That book is my primary inspiration for this series. Without clean architecture, we&amp;rsquo;ll all be building firmware (my paraphrased summary).&lt;/p></description></item></channel></rss>