<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Elm on cekrem.github.io</title><link>https://cekrem.github.io/tags/elm/</link><description>Recent content in Elm on cekrem.github.io</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 31 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://cekrem.github.io/tags/elm/index.xml" rel="self" type="application/rss+xml"/><item><title>Compiler-Driven Development: Building an Elm Playground That Compiles in the Browser</title><link>https://cekrem.github.io/posts/compiler-driven-development-elm-playground/</link><pubDate>Sun, 31 Aug 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/compiler-driven-development-elm-playground/</guid><description>&lt;p&gt;Sometimes the best solutions emerge from the ashes of failed approaches. This is the story of how I built &lt;a href="https://elm-playground.onrender.com" class="external-link" target="_blank" rel="noopener"&gt;elm-playground&lt;/a&gt; – an interactive Elm environment for teaching &amp;ldquo;compiler-driven development&amp;rdquo; – and how hitting memory limits forced me to discover something even better than my original plan.&lt;/p&gt;
&lt;h2 id="the-mission-teaching-compiler-driven-development"&gt;
 The Mission: Teaching Compiler-Driven Development
 &lt;a class="heading-link" href="#the-mission-teaching-compiler-driven-development"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;ve been planning to host an Elm workshop at &lt;a href="https://enso.no" class="external-link" target="_blank" rel="noopener"&gt;Ensō&lt;/a&gt; with a specific theme: &amp;ldquo;Compiler-driven development.&amp;rdquo; The idea is to showcase how Elm&amp;rsquo;s famously friendly compiler can guide your development process, catching errors before they become runtime surprises and helping you write better code through its helpful error messages.&lt;/p&gt;</description></item><item><title>Making Impossible States Impossible: Type-Safe Domain Modeling with Functional Dependency Injection</title><link>https://cekrem.github.io/posts/making-impossible-states-impossible-with-functional-dependency-injection/</link><pubDate>Mon, 18 Aug 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/making-impossible-states-impossible-with-functional-dependency-injection/</guid><description>&lt;p&gt;Most applications don&amp;rsquo;t fail because algorithms are hard—they fail because our models allow states that make no sense in the domain. &amp;ldquo;User without email but verified&amp;rdquo;, &amp;ldquo;order that&amp;rsquo;s both shipped and cancelled&amp;rdquo;, &amp;ldquo;sum &amp;lt; 0&amp;rdquo;, &amp;ldquo;modal dialog both closed and active&amp;rdquo;. These states should be impossible from the start.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Among the most time-consuming bugs to track down are the ones where we look at our application state and say &amp;ldquo;this shouldn&amp;rsquo;t be possible.&amp;rdquo;&lt;/p&gt;</description></item><item><title>Kotlin's Rich Errors: Native, Typed Errors Without Exceptions</title><link>https://cekrem.github.io/posts/kotlin-rich-errors-elm-union-types/</link><pubDate>Fri, 08 Aug 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/kotlin-rich-errors-elm-union-types/</guid><description>&lt;p&gt;At KotlinConf 2025, the Kotlin team showcased progress toward &lt;strong&gt;Rich Errors&lt;/strong&gt; with union types. After years of watching languages slowly adopt patterns that Elm has championed since day one, it&amp;rsquo;s exciting to see Kotlin taking this significant step toward more explicit, type-safe error handling. And in a very &amp;ldquo;native&amp;rdquo; Kotlin way at that!&lt;/p&gt;
&lt;p&gt;I vividly remember this announcement giving my functional heart a pleasant jolt, but I haven&amp;rsquo;t found the time for a write-up until now. Better late than never, though:&lt;/p&gt;</description></item><item><title>On the Value of Abstractions</title><link>https://cekrem.github.io/posts/on-the-value-of-abstractions/</link><pubDate>Thu, 07 Aug 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/on-the-value-of-abstractions/</guid><description>&lt;p&gt;Most of my day-to-day work is in Elm. The combination of a functional language and the Elm Architecture makes many architectural decisions almost invisible (I talk more about that &lt;a href="https://cekrem.github.io/posts/why-i-hope-i-get-to-write-a-lot-of-elm-code-in-2025/#the-elm-architecture-vs-clean-architecture" &gt;in this blog post&lt;/a&gt;). You get a clear separation of concerns, and the language nudges you toward good design by default.&lt;/p&gt;
&lt;p&gt;But my work isn’t limited to Elm. I frequently find myself building features that span both frontend and backend—writing new endpoints, and sometimes even designing new database tables. When I step outside the Elm world, I’m reminded that architecture is something I have to be intentional about again.&lt;/p&gt;</description></item><item><title>Tailwind IntelliSense in Elm: A NeoVim Recipe</title><link>https://cekrem.github.io/posts/tailwind-intellisense-elm-neovim/</link><pubDate>Fri, 04 Jul 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/tailwind-intellisense-elm-neovim/</guid><description>&lt;p&gt;If you&amp;rsquo;re using Elm with Tailwind CSS in NeoVim, you&amp;rsquo;ve probably noticed that IntelliSense doesn&amp;rsquo;t work out of the box. Here&amp;rsquo;s a quick recipe to fix that.&lt;/p&gt;
&lt;h2 id="the-problem"&gt;
 The Problem
 &lt;a class="heading-link" href="#the-problem"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Tailwind&amp;rsquo;s LSP doesn&amp;rsquo;t recognize Elm&amp;rsquo;s syntax for CSS classes. When you write:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-elm" data-lang="elm"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#ff5c57"&gt;div&lt;/span&gt; [ &lt;span style="color:#ff5c57"&gt;class&lt;/span&gt; &lt;span style="color:#5af78e"&gt;&amp;#34;bg-blue-500 text-white p-4&amp;#34;&lt;/span&gt; ] [ &lt;span style="color:#ff5c57"&gt;text&lt;/span&gt; &lt;span style="color:#5af78e"&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt; ]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You get no autocomplete, no validation, and no hover documentation for your Tailwind classes.&lt;/p&gt;</description></item><item><title>Pragmatic Hacks: When 'Good Enough' is Actually Good Enough</title><link>https://cekrem.github.io/posts/pragmatic-hacks-search-widget-elm/</link><pubDate>Mon, 23 Jun 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/pragmatic-hacks-search-widget-elm/</guid><description>&lt;p&gt;Sometimes the best solution isn&amp;rsquo;t the most elegant one. Sometimes it&amp;rsquo;s the one that works, ships quickly, and solves the problem at hand. This is the story of how I built a search widget for my blog using what purists might call &amp;ldquo;hacks&amp;rdquo; – and why that was exactly the right choice.&lt;/p&gt;
&lt;p&gt;If you haven&amp;rsquo;t already I suggest you check out &lt;a href="https://cekrem.github.io/posts/starting-small-with-elm-a-widget-approach/" &gt;Starting Small with Elm: A Widget Approach&lt;/a&gt; for some context; that&amp;rsquo;s where this Elm widget stuff all begun.&lt;/p&gt;</description></item><item><title>Starting Small with Elm: A Widget Approach</title><link>https://cekrem.github.io/posts/starting-small-with-elm-a-widget-approach/</link><pubDate>Tue, 03 Jun 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/starting-small-with-elm-a-widget-approach/</guid><description>&lt;p&gt;It&amp;rsquo;s awesome to learn Elm by building a side project, you absolutely should. And maybe you have – perhaps you&amp;rsquo;ve built a todo app, explored The Elm Architecture, and fallen in love with the reliability and maintainability that comes with functional programming and strong types.&lt;/p&gt;
&lt;p&gt;But come Monday morning, you&amp;rsquo;re back to wrestling with JavaScript bugs, runtime errors, and the nagging feeling that there has to be a better way. The problem isn&amp;rsquo;t that Elm isn&amp;rsquo;t ready for production work – it absolutely is. The problem is convincing your team, your boss, or your organization to take the leap. And when you&amp;rsquo;re thinking about wholesale replacement, your boss&amp;rsquo;s skepticism might be quite healthy. But here&amp;rsquo;s the thing: if you reduce the scope, you can also reduce the risk and buy-in required. Instead of &amp;ldquo;let&amp;rsquo;s rebuild our entire app in Elm,&amp;rdquo; what if the conversation was &amp;ldquo;let&amp;rsquo;s try Elm for this one small widget&amp;rdquo;? Suddenly, the stakes drop dramatically.&lt;/p&gt;</description></item><item><title>A Use Case for Port Boundaries in Frontend Development</title><link>https://cekrem.github.io/posts/a-case-for-port-boundaries-in-frontend/</link><pubDate>Mon, 19 May 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/a-case-for-port-boundaries-in-frontend/</guid><description>&lt;p&gt;In the Elm ecosystem, the browser is treated like an I/O device. DOM events, JavaScript interop, and even network requests are kept outside the core logic. Rather than allowing side effects to permeate the codebase, Elm channels them through strictly typed boundaries known as &lt;em&gt;ports&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This architectural stance is both radical and liberating. It allows you to build user interfaces where logic remains pure, testable, and robust, even as surrounding technologies evolve.&lt;/p&gt;</description></item><item><title>Introducing HTML Helpers for Elm</title><link>https://cekrem.github.io/posts/introducing-html-helpers-for-elm/</link><pubDate>Tue, 06 May 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/introducing-html-helpers-for-elm/</guid><description>&lt;p&gt;As I continue to build more Elm applications, I find myself creating small utility functions to overcome common pain points. I&amp;rsquo;m a big fan of abstracting away repetitive patterns into reusable, well-named functions. Today, I&amp;rsquo;m happy to announce the release of my first public Elm package: &lt;a href="https://package.elm-lang.org/packages/cekrem/html-helpers/latest/" class="external-link" target="_blank" rel="noopener"&gt;html-helpers&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="whats-the-problem"&gt;
 What&amp;rsquo;s the Problem?
 &lt;a class="heading-link" href="#whats-the-problem"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Elm&amp;rsquo;s HTML API is quite straightforward - you create HTML elements as functions, pass them attributes and children, and compose them together. But a few cases come up repeatedly that can be awkward:&lt;/p&gt;</description></item><item><title>Building Better UI Components: Elm Ports with Web Components</title><link>https://cekrem.github.io/posts/elm-ports-with-web-components/</link><pubDate>Wed, 19 Mar 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/elm-ports-with-web-components/</guid><description>&lt;p&gt;One of the most common questions I get about Elm is: &amp;ldquo;How do I integrate it with existing JavaScript ecosystems?&amp;rdquo; While Elm&amp;rsquo;s isolation is a strength, real-world projects often require working with external libraries, APIs, or UI components. Doing incremental migration is also the recommended way to introduce Elm, and luckily there are may ways to accomplish this.&lt;/p&gt;
&lt;p&gt;Today, I&amp;rsquo;ll show you how to combine two powerful technologies:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Elm Ports&lt;/strong&gt;: The official way to communicate between Elm and JavaScript&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web Components&lt;/strong&gt;: Standard, framework-agnostic UI components&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This combination gives us the best of both worlds: Elm&amp;rsquo;s type safety and predictable architecture alongside the reusability and interoperability of Web Components. Let&amp;rsquo;s dive in!&lt;/p&gt;</description></item><item><title>Feedback.one: A Refreshing Take on User Feedback Built with Elm and Rust</title><link>https://cekrem.github.io/posts/feedback-one-elm-rust-feedback-widget/</link><pubDate>Thu, 13 Mar 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/feedback-one-elm-rust-feedback-widget/</guid><description>&lt;p&gt;I recently added a new feedback widget to this site – &lt;a href="https://feedback.one/" class="external-link" target="_blank" rel="noopener"&gt;Feedback.one&lt;/a&gt; – and I&amp;rsquo;m impressed enough with it that I thought it deserved its own post. Beyond being a useful tool, it&amp;rsquo;s also an excellent example of how functional programming languages like Elm can shine in production environments.&lt;/p&gt;
&lt;h2 id="what-is-feedbackone"&gt;
 What is Feedback.one?
 &lt;a class="heading-link" href="#what-is-feedbackone"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;At its core, Feedback.one is a simple but powerful tool that adds a non-intrusive feedback button to your website. With one line of code, you get:&lt;/p&gt;</description></item><item><title>Why I Hope I Get to Write a Lot of Elm Code in 2025</title><link>https://cekrem.github.io/posts/why-i-hope-i-get-to-write-a-lot-of-elm-code-in-2025/</link><pubDate>Tue, 04 Mar 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/why-i-hope-i-get-to-write-a-lot-of-elm-code-in-2025/</guid><description>&lt;p&gt;In a world dominated by React, Vue, and Svelte, it might seem strange to highlight Elm – a niche language that has existed since 2012 but has had fewer releases since then than React has in a year. But right now, when frontend development is becoming increasingly complex, and clients are doing heavy lifting that previously belonged on the other side of an API call, it&amp;rsquo;s worth taking a closer look at what Elm does right.&lt;/p&gt;</description></item><item><title>create-elm-live-app – the smallest npm package ever?</title><link>https://cekrem.github.io/posts/create-elm-live-app/</link><pubDate>Thu, 08 Jul 2021 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/create-elm-live-app/</guid><description>&lt;h2 id="the-problem"&gt;
 The problem
 &lt;a class="heading-link" href="#the-problem"&gt;
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"&gt;&lt;/i&gt;
 &lt;span class="sr-only"&gt;Link to heading&lt;/span&gt;
 &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;ve been tinkering a bit with Elm lately. The super-enforced functional and minimal paradigm is very refreshing, and serves as a sort of detox after spending one too many hour stuck in Android&amp;rsquo;s not-so-lovely XML + mutating class world. Setting up a new bare minimum Elm app should be quite simple, but it turns out that there are a few more steps required than one would expect. My first instinct – being a React guy – was to try &lt;code&gt;yarn create elm-app&lt;/code&gt; (or &lt;code&gt;npx create-elm-app&lt;/code&gt;), hoping it would do the Elm-equivalent of what &lt;code&gt;create-react-app&lt;/code&gt; does. Turns out, to my disappointment, that the end result leaves something to be desired. No proper live-reload out of the box, and a lot of the webpack stuff I was hoping to avoid completely with Elm. Yuck.&lt;/p&gt;</description></item></channel></rss>