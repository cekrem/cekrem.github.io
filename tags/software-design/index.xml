<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Software Design on cekrem.github.io</title><link>https://cekrem.github.io/tags/software-design/</link><description>Recent content in Software Design on cekrem.github.io</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 07 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://cekrem.github.io/tags/software-design/index.xml" rel="self" type="application/rss+xml"/><item><title>On the Value of Abstractions</title><link>https://cekrem.github.io/posts/on-the-value-of-abstractions/</link><pubDate>Thu, 07 Aug 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/on-the-value-of-abstractions/</guid><description>&lt;p&gt;Most of my day-to-day work is in Elm. The combination of a functional language and the Elm Architecture makes many architectural decisions almost invisible (I talk more about that &lt;a href="https://cekrem.github.io/posts/why-i-hope-i-get-to-write-a-lot-of-elm-code-in-2025/#the-elm-architecture-vs-clean-architecture" &gt;in this blog post&lt;/a&gt;). You get a clear separation of concerns, and the language nudges you toward good design by default.&lt;/p&gt;
&lt;p&gt;But my work isn’t limited to Elm. I frequently find myself building features that span both frontend and backend—writing new endpoints, and sometimes even designing new database tables. When I step outside the Elm world, I’m reminded that architecture is something I have to be intentional about again.&lt;/p&gt;</description></item><item><title>A Use Case for Port Boundaries in Frontend Development</title><link>https://cekrem.github.io/posts/a-case-for-port-boundaries-in-frontend/</link><pubDate>Mon, 19 May 2025 00:00:00 +0000</pubDate><guid>https://cekrem.github.io/posts/a-case-for-port-boundaries-in-frontend/</guid><description>&lt;p&gt;In the Elm ecosystem, the browser is treated like an I/O device. DOM events, JavaScript interop, and even network requests are kept outside the core logic. Rather than allowing side effects to permeate the codebase, Elm channels them through strictly typed boundaries known as &lt;em&gt;ports&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This architectural stance is both radical and liberating. It allows you to build user interfaces where logic remains pure, testable, and robust, even as surrounding technologies evolve.&lt;/p&gt;</description></item></channel></rss>